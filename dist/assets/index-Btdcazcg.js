import{cW as Z,cX as X,cY as Rt,cZ as qt,c_ as de,c$ as vt,d0 as fe,ar as q,d1 as he,d2 as le,d3 as me,d4 as pe,d5 as ge,d6 as Ut,d7 as Nt,d8 as ye,d9 as S,da as tt,db as pt,dc as zt,dd as Bt,de as xe,df as Lt,dg as _,dh as kt,di as we,dj as be,dk as Ee,dl as Ie,dm as Te,dn as Pe,dp as ve,dq as C,dr as P,ds as Ae,at as Ce,dt as Se,du as Fe,dv as _e,dw as Gt,dx as Re,U as qe,dy as Ue,dz as Ne,dA as ze,dB as M,dC as B,dD as L,aP as Y,dE as Mt,dF as Be,dG as Le,dH as v,dI as ke,dJ as Ge,dK as Me,dL as De,dM as et,dN as gt,dO as yt,dP as $e,dQ as He,dR as Dt,dS as $t,dT as Oe,dU as Ve,dV as je,dW as We,dX as Ke,aS as z,bA as b,c5 as G,dY as Ye,dZ as Je,d_ as Ze,d$ as Ht,e0 as Ot,e1 as $,aN as N,e2 as R,e3 as Q,az as Xe,e4 as Qe,aT as nt,e5 as mt,aB as w,e6 as tn,e7 as en,e8 as j,e9 as rt,ea as nn,eb as rn,av as st,ec as sn,B as Vt,ed as an,ee as on,ef as H,eg as At,eh as cn,ei as un,ej as jt,ek as Wt,el as dn,em as fn,h as hn,v as ln,i as mn,en as pn,eo as Ct,ep as xt,eq as gn}from"./index-7FzYWXJd.js";import{gq as vs,gr as As,gs as Cs,gt as Ss,gu as Fs,gv as _s,gw as Rs,gx as qs,gy as Us,gz as Ns,gA as zs,gB as Bs,gC as Ls,gD as ks,hN as Gs,gV as Ms,gW as Ds,gS as $s,gL as Hs,gX as Os,gM as Vs,gY as js,hi as Ws,er as Ks,hj as Ys,gN as Js,gO as Zs,gP as Xs,gR as Qs,gE as ta,gF as ea,gZ as na,gT as ra,hp as sa,hq as aa,ho as oa,hr as ia,hs as ca,hF as ua,hA as da,aA as fa,ht as ha,hl as la,g_ as ma,hu as pa,hv as ga,gG as ya,gH as xa,es as wa,et as ba,gI as Ea,hk as Ia,gJ as Ta,hP as Pa,eu as va,hm as Aa,g$ as Ca,ev as Sa,ew as Fa,h0 as _a,ex as Ra,hQ as qa,h1 as Ua,hG as Na,ey as za,ez as Ba,hR as La,h2 as ka,h3 as Ga,gU as Ma,h4 as Da,h5 as $a,hw as Ha,hx as Oa,hy as Va,h6 as ja,h7 as Wa,h8 as Ka,gQ as Ya,h9 as Ja,ha as Za,hb as Xa,hB as Qa,hK as to,hn as eo,hL as no,hD as ro,eA as so,hO as ao,S as oo,hC as io,hH as co,hI as uo,hz as fo,hc as ho,hd as lo,he as mo,eC as po,eB as go,hf as yo,hg as xo,hh as wo,hM as bo,hJ as Eo,hE as Io,ij as To,im as Po,io as vo,ip as Ao,ig as Co,iq as So,it as Fo,eG as _o,au as Ro,hX as qo,hY as Uo,hZ as No,hU as zo,iu as Bo,i3 as Lo,i6 as ko,i8 as Go,eS as Mo,eT as Do,iL as $o,a9 as Ho,h_ as Oo,h$ as Vo,i1 as jo,eN as Wo,eK as Ko,eL as Yo,eO as Jo,eM as Zo,eQ as Xo,hV as Qo,iz as ti,iA as ei,hW as ni,i4 as ri,i7 as si,iB as ai,ir as oi,iC as ii,ia as ci,iv as ui,iF as di,iG as fi,E as hi,iG as li,ib as mi,ic as pi,iD as gi,ih as yi,iE as xi,eF as wi,hS as bi,f6 as Ei,f7 as Ii,f8 as Ti,f9 as Pi,fa as vi,fb as Ai,fc as Ci,eX as Si,fd as Fi,fe as _i,ff as Ri,fg as qi,fh as Ui,fi as Ni,fj as zi,fk as Bi,fl as Li,fm as ki,eY as Gi,fn as Mi,fo as Di,fp as $i,eZ as Hi,e_ as Oi,e$ as Vi,f0 as ji,f1 as Wi,f2 as Ki,eW as Yi,f3 as Ji,f4 as Zi,f5 as Xi,fB as Qi,fC as tc,fD as ec,fE as nc,fF as rc,fG as sc,fH as ac,aM as oc,fI as ic,fJ as cc,fK as uc,fL as dc,fM as fc,fN as hc,fO as lc,fP as mc,fQ as pc,fR as gc,fr as yc,fS as xc,fT as wc,fs as bc,ft as Ec,fu as Ic,fv as Tc,fw as Pc,fx as vc,fq as Ac,fy as Cc,fz as Sc,fA as Fc,g4 as _c,g5 as Rc,g6 as qc,g7 as Uc,g8 as Nc,g9 as zc,ga as Bc,fV as Lc,gb as kc,gc as Gc,gd as Mc,ge as Dc,gf as $c,gg as Hc,gh as Oc,gi as Vc,gj as jc,gk as Wc,fW as Kc,gl as Yc,gm as Jc,gn as Zc,fX as Xc,fY as Qc,fZ as tu,f_ as eu,f$ as nu,g0 as ru,fU as su,g1 as au,g2 as ou,g3 as iu,eJ as cu,hT as uu,ik as du,iJ as fu,b9 as hu,eD as lu,i2 as mu,i0 as pu,gp as gu,eH as yu,id as xu,eE as wu,i9 as bu,ii as Eu,ie as Iu,gK as Tu,aO as Pu,ie as vu,iK as Au,il as Cu,is as Su,iH as Fu,iF as _u,iG as Ru,iH as qu,E as Uu,iG as Nu,iI as zu,i5 as Bu,eP as Lu,eU as ku,eI as Gu,eV as Mu,iw as Du,ix as $u,iy as Hu,eR as Ou,go as Vu}from"./index-7FzYWXJd.js";import{ccipRequest as Wu,ccipRequest as Ku,offchainLookup as Yu,offchainLookupAbiItem as Ju,offchainLookupSignature as Zu}from"./ccip-CxHmFqx9.js";function Kr(t){let e;if(typeof t=="string")e=Z(t,{modifiers:X});else{const n=Rt(t),r=t.length;for(let s=0;s<r;s++){const a=t[s];if(!qt(a)){e=Z(a,{modifiers:X,structs:n});break}}}if(!e)throw new de({param:t});return e}function Yr(t){const e=[];if(typeof t=="string"){const n=vt(t),r=n.length;for(let s=0;s<r;s++)e.push(Z(n[s],{modifiers:X}))}else{const n=Rt(t),r=t.length;for(let s=0;s<r;s++){const a=t[s];if(qt(a))continue;const o=vt(a),i=o.length;for(let c=0;c<i;c++)e.push(Z(o[c],{modifiers:X,structs:n}))}}if(e.length===0)throw new fe({params:t});return e}class U extends q{constructor({docsPath:e}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:e,docsSlug:"account",name:"AccountNotFoundError"})}}class J extends q{constructor({docsPath:e,metaMessages:n,type:r}){super(`Account type "${r}" is not supported.`,{docsPath:e,metaMessages:n,name:"AccountTypeNotSupportedError"})}}function Kt({chain:t,currentChainId:e}){if(!t)throw new he;if(e!==t.id)throw new le({chain:t,currentChainId:e})}function Yt(t,{docsPath:e,...n}){const r=(()=>{const s=me(t,n);return s instanceof pe?t:s})();return new ge(r,{docsPath:e,...n})}const ft=new Ut(128);async function wt(t,e){var T,I,E,A;const{account:n=t.account,chain:r=t.chain,accessList:s,authorizationList:a,blobs:o,data:i,gas:c,gasPrice:u,maxFeePerBlobGas:h,maxFeePerGas:f,maxPriorityFeePerGas:l,nonce:d,value:g,...m}=e;if(typeof n>"u")throw new U({docsPath:"/docs/actions/wallet/sendTransaction"});const p=n?_(n):null;try{Nt(e);const x=await(async()=>{if(e.to)return e.to;if(e.to!==null&&a&&a.length>0)return await ye({authorization:a[0]}).catch(()=>{throw new q("`to` is required. Could not infer from `authorizationList`.")})})();if((p==null?void 0:p.type)==="json-rpc"||p===null){let y;r!==null&&(y=await S(t,tt,"getChainId")({}),Kt({currentChainId:y,chain:r}));const F=(E=(I=(T=t.chain)==null?void 0:T.formatters)==null?void 0:I.transactionRequest)==null?void 0:E.format,It=(F||pt)({...zt(m,{format:F}),accessList:s,authorizationList:a,blobs:o,chainId:y,data:i,from:p==null?void 0:p.address,gas:c,gasPrice:u,maxFeePerBlobGas:h,maxFeePerGas:f,maxPriorityFeePerGas:l,nonce:d,to:x,value:g}),Tt=ft.get(t.uid),ue=Tt?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:ue,params:[It]},{retryCount:0})}catch(Pt){if(Tt===!1)throw Pt;const k=Pt;if(k.name==="InvalidInputRpcError"||k.name==="InvalidParamsRpcError"||k.name==="MethodNotFoundRpcError"||k.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[It]},{retryCount:0}).then(ut=>(ft.set(t.uid,!0),ut)).catch(ut=>{const dt=ut;throw dt.name==="MethodNotFoundRpcError"||dt.name==="MethodNotSupportedRpcError"?(ft.set(t.uid,!1),k):dt});throw k}}if((p==null?void 0:p.type)==="local"){const y=await S(t,Bt,"prepareTransactionRequest")({account:p,accessList:s,authorizationList:a,blobs:o,chain:r,data:i,gas:c,gasPrice:u,maxFeePerBlobGas:h,maxFeePerGas:f,maxPriorityFeePerGas:l,nonce:d,nonceManager:p.nonceManager,parameters:[...xe,"sidecars"],value:g,...m,to:x}),F=(A=r==null?void 0:r.serializers)==null?void 0:A.transaction,D=await p.signTransaction(y,{serializer:F});return await S(t,Lt,"sendRawTransaction")({serializedTransaction:D})}throw(p==null?void 0:p.type)==="smart"?new J({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new J({docsPath:"/docs/actions/wallet/sendTransaction",type:p==null?void 0:p.type})}catch(x){throw x instanceof J?x:Yt(x,{...e,account:p,chain:e.chain||void 0})}}async function Jt(t,e){const{abi:n,account:r=t.account,address:s,args:a,dataSuffix:o,functionName:i,...c}=e;if(typeof r>"u")throw new U({docsPath:"/docs/contract/writeContract"});const u=r?_(r):null,h=kt({abi:n,args:a,functionName:i});try{return await S(t,wt,"sendTransaction")({data:`${h}${o?o.replace("0x",""):""}`,to:s,account:u,...c})}catch(f){throw we(f,{abi:n,address:s,args:a,docsPath:"/docs/contract/writeContract",functionName:i,sender:u==null?void 0:u.address})}}function Jr({abi:t,address:e,client:n}){const r=n,[s,a]=r?"public"in r&&"wallet"in r?[r.public,r.wallet]:"public"in r?[r.public,void 0]:"wallet"in r?[void 0,r.wallet]:[r,r]:[void 0,void 0],o=s!=null,i=a!=null,c={};let u=!1,h=!1,f=!1;for(const l of t)if(l.type==="function"?l.stateMutability==="view"||l.stateMutability==="pure"?u=!0:h=!0:l.type==="event"&&(f=!0),u&&h&&f)break;return o&&(u&&(c.read=new Proxy({},{get(l,d){return(...g)=>{const{args:m,options:p}=W(g);return S(s,be,"readContract")({abi:t,address:e,functionName:d,args:m,...p})}}})),h&&(c.simulate=new Proxy({},{get(l,d){return(...g)=>{const{args:m,options:p}=W(g);return S(s,Ee,"simulateContract")({abi:t,address:e,functionName:d,args:m,...p})}}})),f&&(c.createEventFilter=new Proxy({},{get(l,d){return(...g)=>{const m=t.find(I=>I.type==="event"&&I.name===d),{args:p,options:T}=ht(g,m);return S(s,Ie,"createContractEventFilter")({abi:t,address:e,eventName:d,args:p,...T})}}}),c.getEvents=new Proxy({},{get(l,d){return(...g)=>{const m=t.find(I=>I.type==="event"&&I.name===d),{args:p,options:T}=ht(g,m);return S(s,Te,"getContractEvents")({abi:t,address:e,eventName:d,args:p,...T})}}}),c.watchEvent=new Proxy({},{get(l,d){return(...g)=>{const m=t.find(I=>I.type==="event"&&I.name===d),{args:p,options:T}=ht(g,m);return S(s,Pe,"watchContractEvent")({abi:t,address:e,eventName:d,args:p,...T})}}}))),i&&h&&(c.write=new Proxy({},{get(l,d){return(...g)=>{const{args:m,options:p}=W(g);return S(a,Jt,"writeContract")({abi:t,address:e,functionName:d,args:m,...p})}}})),(o||i)&&h&&(c.estimateGas=new Proxy({},{get(l,d){return(...g)=>{const{args:m,options:p}=W(g);return S(s??a,ve,"estimateContractGas")({abi:t,address:e,functionName:d,args:m,...p,account:p.account??a.account})}}})),c.address=e,c.abi=t,c}function W(t){const e=t.length&&Array.isArray(t[0]),n=e?t[0]:[],r=(e?t[1]:t[0])??{};return{args:n,options:r}}function ht(t,e){let n=!1;Array.isArray(t[0])?n=!0:t.length===1?n=e.inputs.some(a=>a.indexed):t.length===2&&(n=!0);const r=n?t[0]:void 0,s=(n?t[1]:t[0])??{};return{args:r,options:s}}async function Zt(t,e){const{atomic:n=!1,chainId:r,receipts:s,version:a="2.0.0",...o}=await t.request({method:"wallet_getCallsStatus",params:[e.id]}),[i,c]=(()=>{const u=o.status;return u>=100&&u<200?["pending",u]:u>=200&&u<300?["success",u]:u>=300&&u<700?["failure",u]:u==="CONFIRMED"?["success",200]:u==="PENDING"?["pending",100]:[void 0,u]})();return{...o,atomic:n,chainId:r?C(r):void 0,receipts:(s==null?void 0:s.map(u=>({...u,blockNumber:P(u.blockNumber),gasUsed:P(u.gasUsed),status:Ae[u.status]})))??[],statusCode:c,status:i,version:a}}async function yn(t,e){const{id:n,pollingInterval:r=t.pollingInterval,status:s=({statusCode:l})=>l>=200,timeout:a=6e4}=e,o=Ce(["waitForCallsStatus",t.uid,n]),{promise:i,resolve:c,reject:u}=Se();let h;const f=Fe(o,{resolve:c,reject:u},l=>{const d=_e(async()=>{const g=m=>{clearTimeout(h),d(),m(),f()};try{const m=await Zt(t,{id:n});if(!s(m))return;g(()=>l.resolve(m))}catch(m){g(()=>l.reject(m))}},{interval:r,emitOnBegin:!0});return d});return h=a?setTimeout(()=>{f(),clearTimeout(h),u(new xn({id:n}))},a):void 0,await i}class xn extends q{constructor({id:e}){super(`Timed out while waiting for call bundle with id "${e}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}function Zr(t,e={}){const{key:n="custom",methods:r,name:s="Custom Provider",retryDelay:a}=e;return({retryCount:o})=>Gt({key:n,methods:r,name:s,request:t.request.bind(t),retryCount:e.retryCount??o,retryDelay:a,type:"custom"})}function Xr(t,e={}){const{key:n="fallback",name:r="Fallback",rank:s=!1,shouldThrow:a=wn,retryCount:o,retryDelay:i}=e;return({chain:c,pollingInterval:u=4e3,timeout:h,...f})=>{let l=t,d=()=>{};const g=Gt({key:n,name:r,async request({method:m,params:p}){let T;const I=async(E=0)=>{const A=l[E]({...f,chain:c,retryCount:0,timeout:h});try{const x=await A.request({method:m,params:p});return d({method:m,params:p,response:x,transport:A,status:"success"}),x}catch(x){if(d({error:x,method:m,params:p,transport:A,status:"error"}),a(x)||E===l.length-1||(T??(T=l.slice(E+1).some(y=>{const{include:F,exclude:D}=y({chain:c}).config.methods||{};return F?F.includes(m):D?!D.includes(m):!0})),!T))throw x;return I(E+1)}};return I()},retryCount:o,retryDelay:i,type:"fallback"},{onResponse:m=>d=m,transports:l.map(m=>m({chain:c,retryCount:0}))});if(s){const m=typeof s=="object"?s:{};bn({chain:c,interval:m.interval??u,onTransports:p=>l=p,ping:m.ping,sampleCount:m.sampleCount,timeout:m.timeout,transports:l,weights:m.weights})}return g}}function wn(t){return!!("code"in t&&typeof t.code=="number"&&(t.code===Re.code||t.code===qe.code||Ue.nodeMessage.test(t.message)||t.code===5e3))}function bn({chain:t,interval:e=4e3,onTransports:n,ping:r,sampleCount:s=10,timeout:a=1e3,transports:o,weights:i={}}){const{stability:c=.7,latency:u=.3}=i,h=[],f=async()=>{const l=await Promise.all(o.map(async m=>{const p=m({chain:t,retryCount:0,timeout:a}),T=Date.now();let I,E;try{await(r?r({transport:p}):p.request({method:"net_listening"})),E=1}catch{E=0}finally{I=Date.now()}return{latency:I-T,success:E}}));h.push(l),h.length>s&&h.shift();const d=Math.max(...h.map(m=>Math.max(...m.map(({latency:p})=>p)))),g=o.map((m,p)=>{const T=h.map(y=>y[p].latency),E=1-T.reduce((y,F)=>y+F,0)/T.length/d,A=h.map(y=>y[p].success),x=A.reduce((y,F)=>y+F,0)/A.length;return x===0?[0,p]:[u*E+c*x,p]}).sort((m,p)=>p[0]-m[0]);n(g.map(([,m])=>o[m])),await Ne(e),f()};f()}function Qr({chains:t,id:e}){return t.find(n=>n.id===e)}function ts(t,e){if(t.length!==e.length)throw new ze({expectedLength:t.length,givenLength:e.length});const n=[];for(let r=0;r<t.length;r++){const s=t[r],a=e[r];n.push(Xt(s,a))}return M(n)}function Xt(t,e,n=!1){if(t==="address"){const o=e;if(!B(o))throw new L({address:o});return Y(o.toLowerCase(),{size:n?32:null})}if(t==="string")return Mt(e);if(t==="bytes")return e;if(t==="bool")return Y(Be(e),{size:n?32:1});const r=t.match(Le);if(r){const[o,i,c="256"]=r,u=Number.parseInt(c)/8;return v(e,{size:n?32:u,signed:i==="int"})}const s=t.match(ke);if(s){const[o,i]=s;if(Number.parseInt(i)!==(e.length-2)/2)throw new Ge({expectedSize:Number.parseInt(i),givenSize:(e.length-2)/2});return Y(e,{dir:"right",size:n?32:null})}const a=t.match(Me);if(a&&Array.isArray(e)){const[o,i]=a,c=[];for(let u=0;u<e.length;u++)c.push(Xt(i,e[u],!0));return c.length===0?"0x":M(c)}throw new De(t)}function Qt(t){const{authorizationList:e}=t;if(e)for(const n of e){const{chainId:r}=n,s=n.address;if(!B(s))throw new L({address:s});if(r<0)throw new et({chainId:r})}at(t)}function te(t){const{blobVersionedHashes:e}=t;if(e){if(e.length===0)throw new He;for(const n of e){const r=Dt(n),s=C($t(n,0,1));if(r!==32)throw new Oe({hash:n,size:r});if(s!==Ve)throw new je({hash:n,version:s})}}at(t)}function at(t){const{chainId:e,maxPriorityFeePerGas:n,maxFeePerGas:r,to:s}=t;if(e<=0)throw new et({chainId:e});if(s&&!B(s))throw new L({address:s});if(r&&r>gt)throw new yt({maxFeePerGas:r});if(n&&r&&n>r)throw new $e({maxFeePerGas:r,maxPriorityFeePerGas:n})}function ee(t){const{chainId:e,maxPriorityFeePerGas:n,gasPrice:r,maxFeePerGas:s,to:a}=t;if(e<=0)throw new et({chainId:e});if(a&&!B(a))throw new L({address:a});if(n||s)throw new q("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");if(r&&r>gt)throw new yt({maxFeePerGas:r})}function ne(t){const{chainId:e,maxPriorityFeePerGas:n,gasPrice:r,maxFeePerGas:s,to:a}=t;if(a&&!B(a))throw new L({address:a});if(typeof e<"u"&&e<=0)throw new et({chainId:e});if(n||s)throw new q("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");if(r&&r>gt)throw new yt({maxFeePerGas:r})}function ot(t){if(!t||t.length===0)return[];const e=[];for(let n=0;n<t.length;n++){const{address:r,storageKeys:s}=t[n];for(let a=0;a<s.length;a++)if(s[a].length-2!==64)throw new We({storageKey:s[a]});if(!B(r,{strict:!1}))throw new L({address:r});e.push([r,s])}return e}function En(t,e){const n=Ke(t);return n==="eip1559"?Pn(t,e):n==="eip2930"?vn(t,e):n==="eip4844"?Tn(t,e):n==="eip7702"?In(t,e):An(t,e)}function In(t,e){const{authorizationList:n,chainId:r,gas:s,nonce:a,to:o,value:i,maxFeePerGas:c,maxPriorityFeePerGas:u,accessList:h,data:f}=t;Qt(t);const l=ot(h),d=Cn(n);return M(["0x04",z([b(r),a?b(a):"0x",u?b(u):"0x",c?b(c):"0x",s?b(s):"0x",o??"0x",i?b(i):"0x",f??"0x",l,d,...O(t,e)])])}function Tn(t,e){const{chainId:n,gas:r,nonce:s,to:a,value:o,maxFeePerBlobGas:i,maxFeePerGas:c,maxPriorityFeePerGas:u,accessList:h,data:f}=t;te(t);let l=t.blobVersionedHashes,d=t.sidecars;if(t.blobs&&(typeof l>"u"||typeof d>"u")){const E=typeof t.blobs[0]=="string"?t.blobs:t.blobs.map(y=>G(y)),A=t.kzg,x=Ye({blobs:E,kzg:A});if(typeof l>"u"&&(l=Je({commitments:x})),typeof d>"u"){const y=Ze({blobs:E,commitments:x,kzg:A});d=Ht({blobs:E,commitments:x,proofs:y})}}const g=ot(h),m=[b(n),s?b(s):"0x",u?b(u):"0x",c?b(c):"0x",r?b(r):"0x",a??"0x",o?b(o):"0x",f??"0x",g,i?b(i):"0x",l??[],...O(t,e)],p=[],T=[],I=[];if(d)for(let E=0;E<d.length;E++){const{blob:A,commitment:x,proof:y}=d[E];p.push(A),T.push(x),I.push(y)}return M(["0x03",d?z([m,p,T,I]):z(m)])}function Pn(t,e){const{chainId:n,gas:r,nonce:s,to:a,value:o,maxFeePerGas:i,maxPriorityFeePerGas:c,accessList:u,data:h}=t;at(t);const f=ot(u),l=[b(n),s?b(s):"0x",c?b(c):"0x",i?b(i):"0x",r?b(r):"0x",a??"0x",o?b(o):"0x",h??"0x",f,...O(t,e)];return M(["0x02",z(l)])}function vn(t,e){const{chainId:n,gas:r,data:s,nonce:a,to:o,value:i,accessList:c,gasPrice:u}=t;ee(t);const h=ot(c),f=[b(n),a?b(a):"0x",u?b(u):"0x",r?b(r):"0x",o??"0x",i?b(i):"0x",s??"0x",h,...O(t,e)];return M(["0x01",z(f)])}function An(t,e){const{chainId:n=0,gas:r,data:s,nonce:a,to:o,value:i,gasPrice:c}=t;ne(t);let u=[a?b(a):"0x",c?b(c):"0x",r?b(r):"0x",o??"0x",i?b(i):"0x",s??"0x"];if(e){const h=(()=>{if(e.v>=35n)return(e.v-35n)/2n>0?e.v:27n+(e.v===35n?0n:1n);if(n>0)return BigInt(n*2)+BigInt(35n+e.v-27n);const d=27n+(e.v===27n?0n:1n);if(e.v!==d)throw new Ot({v:e.v});return d})(),f=$(e.r),l=$(e.s);u=[...u,b(h),f==="0x00"?"0x":f,l==="0x00"?"0x":l]}else n>0&&(u=[...u,b(n),"0x","0x"]);return z(u)}function O(t,e){const n=e??t,{v:r,yParity:s}=n;if(typeof n.r>"u")return[];if(typeof n.s>"u")return[];if(typeof r>"u"&&typeof s>"u")return[];const a=$(n.r),o=$(n.s);return[typeof s=="number"?s?b(1):"0x":r===0n?"0x":r===1n?b(1):r===27n?"0x":b(1),a==="0x00"?"0x":a,o==="0x00"?"0x":o]}function Cn(t){if(!t||t.length===0)return[];const e=[];for(const n of t){const{chainId:r,nonce:s,...a}=n,o=n.address;e.push([r?b(r):"0x",o,s?b(s):"0x",...O({},a)])}return e}function St(t){return!t||typeof t!="object"||!("BYTES_PER_ELEMENT"in t)?!1:t.BYTES_PER_ELEMENT===1&&t.constructor.name==="Uint8Array"}function es(t){return t.opcode==="CREATE2"?Fn(t):Sn(t)}function Sn(t){const e=N(R(t.from));let n=N(t.nonce);return n[0]===0&&(n=new Uint8Array([])),R(`0x${Q(z([e,n],"bytes")).slice(26)}`)}function Fn(t){const e=N(R(t.from)),n=Y(St(t.salt)?t.salt:N(t.salt),{size:32}),r="bytecodeHash"in t?St(t.bytecodeHash)?t.bytecodeHash:N(t.bytecodeHash):Q(t.bytecode,"bytes");return R($t(Q(Xe([N("0xff"),e,n,r])),12))}function re(t,e="hex"){const n=(()=>{if(typeof t=="string"){if(t.length>3&&t.length%2!==0)throw new Qe(t);return nt(t)}return t})(),r=mt(n,{recursiveReadLimit:Number.POSITIVE_INFINITY});return se(r,e)}function se(t,e="hex"){if(t.bytes.length===0)return e==="hex"?G(t.bytes):t.bytes;const n=t.readByte();if(n<128&&t.decrementPosition(1),n<192){const s=Ft(t,n,128),a=t.readBytes(s);return e==="hex"?G(a):a}const r=Ft(t,n,192);return _n(t,r,e)}function Ft(t,e,n){if(n===128&&e<128)return 1;if(e<=n+55)return e-n;if(e===n+55+1)return t.readUint8();if(e===n+55+2)return t.readUint16();if(e===n+55+3)return t.readUint24();if(e===n+55+4)return t.readUint32();throw new q("Invalid RLP prefix")}function _n(t,e,n){const r=t.position,s=[];for(;t.position-r<e;)s.push(se(t,n));return s}function Rn(t){return w(t)&&Dt(t)===32}const qn=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),ae=new Uint8Array(new Array(16).fill(0).map((t,e)=>e)),Un=ae.map(t=>(9*t+5)%16);let bt=[ae],Et=[Un];for(let t=0;t<4;t++)for(let e of[bt,Et])e.push(e[t].map(n=>qn[n]));const oe=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>new Uint8Array(t)),Nn=bt.map((t,e)=>t.map(n=>oe[e][n])),zn=Et.map((t,e)=>t.map(n=>oe[e][n])),Bn=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),Ln=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]);function _t(t,e,n,r){return t===0?e^n^r:t===1?e&n|~e&r:t===2?(e|~n)^r:t===3?e&r|n&~r:e^(n|~r)}const K=new Uint32Array(16);class kn extends en{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:e,h1:n,h2:r,h3:s,h4:a}=this;return[e,n,r,s,a]}set(e,n,r,s,a){this.h0=e|0,this.h1=n|0,this.h2=r|0,this.h3=s|0,this.h4=a|0}process(e,n){for(let d=0;d<16;d++,n+=4)K[d]=e.getUint32(n,!0);let r=this.h0|0,s=r,a=this.h1|0,o=a,i=this.h2|0,c=i,u=this.h3|0,h=u,f=this.h4|0,l=f;for(let d=0;d<5;d++){const g=4-d,m=Bn[d],p=Ln[d],T=bt[d],I=Et[d],E=Nn[d],A=zn[d];for(let x=0;x<16;x++){const y=j(r+_t(d,a,i,u)+K[T[x]]+m,E[x])+f|0;r=f,f=u,u=j(i,10)|0,i=a,a=y}for(let x=0;x<16;x++){const y=j(s+_t(g,o,c,h)+K[I[x]]+p,A[x])+l|0;s=l,l=h,h=j(c,10)|0,c=o,o=y}}this.set(this.h1+i+h|0,this.h2+u+l|0,this.h3+f+s|0,this.h4+r+o|0,this.h0+a+c|0)}roundClean(){K.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const Gn=tn(()=>new kn);function ns(t,e){const n=e||"hex",r=Gn(w(t,{strict:!1})?N(t):t);return n==="bytes"?r:b(r)}async function Mn({message:t,signature:e}){return rt({hash:nn(t),signature:e})}async function Dn(t){const{domain:e,message:n,primaryType:r,signature:s,types:a}=t;return rt({hash:rn({domain:e,message:n,primaryType:r,types:a}),signature:s})}async function rs({address:t,hash:e,signature:n}){return st(R(t),await rt({hash:e,signature:n}))}async function ss({address:t,message:e,signature:n}){return st(R(t),await Mn({message:e,signature:n}))}async function as(t){const{address:e,domain:n,message:r,primaryType:s,signature:a,types:o}=t;return st(R(e),await Dn({domain:n,message:r,primaryType:s,signature:a,types:o}))}function os(t){if(!sn(t))return{signature:t};const[e,n,r]=Vt([{type:"address"},{type:"bytes"},{type:"bytes"}],t);return{address:e,data:n,signature:r}}function $n(t){const e=an(t,0,1);if(e==="0x04")return"eip7702";if(e==="0x03")return"eip4844";if(e==="0x02")return"eip1559";if(e==="0x01")return"eip2930";if(e!=="0x"&&C(e)>=192)return"legacy";throw new on({serializedType:e})}function Hn(t){const e=$n(t);return e==="eip1559"?jn(t):e==="eip2930"?Wn(t):e==="eip4844"?Vn(t):e==="eip7702"?On(t):Kn(t)}function On(t){const e=it(t),[n,r,s,a,o,i,c,u,h,f,l,d,g]=e;if(e.length!==10&&e.length!==13)throw new H({attributes:{chainId:n,nonce:r,maxPriorityFeePerGas:s,maxFeePerGas:a,gas:o,to:i,value:c,data:u,accessList:h,authorizationList:f,...e.length>9?{v:l,r:d,s:g}:{}},serializedTransaction:t,type:"eip7702"});const m={chainId:C(n),type:"eip7702"};return w(i)&&i!=="0x"&&(m.to=i),w(o)&&o!=="0x"&&(m.gas=P(o)),w(u)&&u!=="0x"&&(m.data=u),w(r)&&r!=="0x"&&(m.nonce=C(r)),w(c)&&c!=="0x"&&(m.value=P(c)),w(a)&&a!=="0x"&&(m.maxFeePerGas=P(a)),w(s)&&s!=="0x"&&(m.maxPriorityFeePerGas=P(s)),h.length!==0&&h!=="0x"&&(m.accessList=ct(h)),f.length!==0&&f!=="0x"&&(m.authorizationList=Yn(f)),Qt(m),{...e.length===13?V(e):void 0,...m}}function Vn(t){const e=it(t),n=e.length===4,r=n?e[0]:e,s=n?e.slice(1):[],[a,o,i,c,u,h,f,l,d,g,m,p,T,I]=r,[E,A,x]=s;if(!(r.length===11||r.length===14))throw new H({attributes:{chainId:a,nonce:o,maxPriorityFeePerGas:i,maxFeePerGas:c,gas:u,to:h,value:f,data:l,accessList:d,...r.length>9?{v:p,r:T,s:I}:{}},serializedTransaction:t,type:"eip4844"});const y={blobVersionedHashes:m,chainId:C(a),type:"eip4844"};return w(h)&&h!=="0x"&&(y.to=h),w(u)&&u!=="0x"&&(y.gas=P(u)),w(l)&&l!=="0x"&&(y.data=l),w(o)&&o!=="0x"&&(y.nonce=C(o)),w(f)&&f!=="0x"&&(y.value=P(f)),w(g)&&g!=="0x"&&(y.maxFeePerBlobGas=P(g)),w(c)&&c!=="0x"&&(y.maxFeePerGas=P(c)),w(i)&&i!=="0x"&&(y.maxPriorityFeePerGas=P(i)),d.length!==0&&d!=="0x"&&(y.accessList=ct(d)),E&&A&&x&&(y.sidecars=Ht({blobs:E,commitments:A,proofs:x})),te(y),{...r.length===14?V(r):void 0,...y}}function jn(t){const e=it(t),[n,r,s,a,o,i,c,u,h,f,l,d]=e;if(!(e.length===9||e.length===12))throw new H({attributes:{chainId:n,nonce:r,maxPriorityFeePerGas:s,maxFeePerGas:a,gas:o,to:i,value:c,data:u,accessList:h,...e.length>9?{v:f,r:l,s:d}:{}},serializedTransaction:t,type:"eip1559"});const g={chainId:C(n),type:"eip1559"};return w(i)&&i!=="0x"&&(g.to=i),w(o)&&o!=="0x"&&(g.gas=P(o)),w(u)&&u!=="0x"&&(g.data=u),w(r)&&r!=="0x"&&(g.nonce=C(r)),w(c)&&c!=="0x"&&(g.value=P(c)),w(a)&&a!=="0x"&&(g.maxFeePerGas=P(a)),w(s)&&s!=="0x"&&(g.maxPriorityFeePerGas=P(s)),h.length!==0&&h!=="0x"&&(g.accessList=ct(h)),at(g),{...e.length===12?V(e):void 0,...g}}function Wn(t){const e=it(t),[n,r,s,a,o,i,c,u,h,f,l]=e;if(!(e.length===8||e.length===11))throw new H({attributes:{chainId:n,nonce:r,gasPrice:s,gas:a,to:o,value:i,data:c,accessList:u,...e.length>8?{v:h,r:f,s:l}:{}},serializedTransaction:t,type:"eip2930"});const d={chainId:C(n),type:"eip2930"};return w(o)&&o!=="0x"&&(d.to=o),w(a)&&a!=="0x"&&(d.gas=P(a)),w(c)&&c!=="0x"&&(d.data=c),w(r)&&r!=="0x"&&(d.nonce=C(r)),w(i)&&i!=="0x"&&(d.value=P(i)),w(s)&&s!=="0x"&&(d.gasPrice=P(s)),u.length!==0&&u!=="0x"&&(d.accessList=ct(u)),ee(d),{...e.length===11?V(e):void 0,...d}}function Kn(t){const e=re(t,"hex"),[n,r,s,a,o,i,c,u,h]=e;if(!(e.length===6||e.length===9))throw new H({attributes:{nonce:n,gasPrice:r,gas:s,to:a,value:o,data:i,...e.length>6?{v:c,r:u,s:h}:{}},serializedTransaction:t,type:"legacy"});const f={type:"legacy"};if(w(a)&&a!=="0x"&&(f.to=a),w(s)&&s!=="0x"&&(f.gas=P(s)),w(i)&&i!=="0x"&&(f.data=i),w(n)&&n!=="0x"&&(f.nonce=C(n)),w(o)&&o!=="0x"&&(f.value=P(o)),w(r)&&r!=="0x"&&(f.gasPrice=P(r)),ne(f),e.length===6)return f;const l=w(c)&&c!=="0x"?P(c):0n;if(h==="0x"&&u==="0x")return l>0&&(f.chainId=Number(l)),f;const d=l,g=Number((d-35n)/2n);if(g>0)f.chainId=g;else if(d!==27n&&d!==28n)throw new Ot({v:d});return f.v=d,f.s=h,f.r=u,f.yParity=d%2n===0n?1:0,f}function it(t){return re(`0x${t.slice(4)}`,"hex")}function ct(t){const e=[];for(let n=0;n<t.length;n++){const[r,s]=t[n];if(!B(r,{strict:!1}))throw new L({address:r});e.push({address:r,storageKeys:s.map(a=>Rn(a)?a:$(a))})}return e}function Yn(t){const e=[];for(let n=0;n<t.length;n++){const[r,s,a,o,i,c]=t[n];e.push({address:s,chainId:C(r),nonce:C(a),...V([o,i,c])})}return e}function V(t){const e=t.slice(-3),n=e[0]==="0x"||P(e[0])===0n?27n:28n;return{r:At(e[1],{size:32}),s:At(e[2],{size:32}),v:n,yParity:n===27n?0:1}}class Jn extends q{constructor({value:e}){super(`Number \`${e}\` is not a valid decimal number.`,{name:"InvalidDecimalNumberError"})}}function ie(t,e){if(!/^(-?)([0-9]*)\.?([0-9]*)$/.test(t))throw new Jn({value:t});let[n,r="0"]=t.split(".");const s=n.startsWith("-");if(s&&(n=n.slice(1)),r=r.replace(/(0+)$/,""),e===0)Math.round(+`.${r}`)===1&&(n=`${BigInt(n)+1n}`),r="";else if(r.length>e){const[a,o,i]=[r.slice(0,e-1),r.slice(e-1,e),r.slice(e)],c=Math.round(+`${o}.${i}`);c>9?r=`${BigInt(a)+BigInt(1)}0`.padStart(a.length+1,"0"):r=`${a}${c}`,r.length>e&&(r=r.slice(1),n=`${BigInt(n)+1n}`),r=r.slice(0,e)}else r=r.padEnd(e,"0");return BigInt(`${s?"-":""}${n}${r}`)}function is(t,e="wei"){return ie(t,cn[e])}function cs(t,e="wei"){return ie(t,un[e])}function Zn(t){const{source:e}=t,n=new Map,r=new Ut(8192),s=new Map,a=({address:o,chainId:i})=>`${o}.${i}`;return{async consume({address:o,chainId:i,client:c}){const u=a({address:o,chainId:i}),h=this.get({address:o,chainId:i,client:c});this.increment({address:o,chainId:i});const f=await h;return await e.set({address:o,chainId:i},f),r.set(u,f),f},async increment({address:o,chainId:i}){const c=a({address:o,chainId:i}),u=n.get(c)??0;n.set(c,u+1)},async get({address:o,chainId:i,client:c}){const u=a({address:o,chainId:i});let h=s.get(u);return h||(h=(async()=>{try{const l=await e.get({address:o,chainId:i,client:c}),d=r.get(u)??0;return d>0&&l<=d?d+1:(r.delete(u),l)}finally{this.reset({address:o,chainId:i})}})(),s.set(u,h)),(n.get(u)??0)+await h},reset({address:o,chainId:i}){const c=a({address:o,chainId:i});n.delete(c),s.delete(c)}}}function Xn(){return{async get(t){const{address:e,client:n}=t;return jt(n,{address:e,blockTag:"pending"})},set(){}}}const us=Zn({source:Xn()});async function Qn(t,{hash:e}){await t.request({method:`${t.mode}_dropTransaction`,params:[e]})}async function tr(t){return t.request({method:`${t.mode}_dumpState`})}async function er(t){return t.mode==="ganache"?await t.request({method:"eth_mining"}):await t.request({method:`${t.mode}_getAutomine`})}async function nr(t){return await t.request({method:"txpool_content"})}async function rr(t){const{pending:e,queued:n}=await t.request({method:"txpool_status"});return{pending:C(e),queued:C(n)}}async function sr(t,{address:e}){await t.request({method:`${t.mode}_impersonateAccount`,params:[e]})}async function ar(t,{seconds:e}){return await t.request({method:"evm_increaseTime",params:[v(e)]})}async function or(t){return await t.request({method:"txpool_inspect"})}async function ir(t,{state:e}){await t.request({method:`${t.mode}_loadState`,params:[e]})}async function cr(t,{blocks:e,interval:n}){t.mode==="ganache"?await t.request({method:"evm_mine",params:[{blocks:v(e)}]}):await t.request({method:`${t.mode}_mine`,params:[v(e),v(n||0)]})}async function ur(t){await t.request({method:`${t.mode}_removeBlockTimestampInterval`})}async function dr(t,{blockNumber:e,jsonRpcUrl:n}={}){await t.request({method:`${t.mode}_reset`,params:[{forking:{blockNumber:Number(e),jsonRpcUrl:n}}]})}async function fr(t,{id:e}){await t.request({method:"evm_revert",params:[e]})}async function hr(t,e){var T,I,E;const{accessList:n,data:r,from:s,gas:a,gasPrice:o,maxFeePerGas:i,maxPriorityFeePerGas:c,nonce:u,to:h,value:f,...l}=e,d=(E=(I=(T=t.chain)==null?void 0:T.formatters)==null?void 0:I.transactionRequest)==null?void 0:E.format,m=(d||pt)({...zt(l,{format:d}),accessList:n,data:r,from:s,gas:a,gasPrice:o,maxFeePerGas:i,maxPriorityFeePerGas:c,nonce:u,to:h,value:f});return await t.request({method:"eth_sendUnsignedTransaction",params:[m]})}async function lr(t,e){t.mode==="ganache"?e?await t.request({method:"miner_start"}):await t.request({method:"miner_stop"}):await t.request({method:"evm_setAutomine",params:[e]})}async function mr(t,{address:e,value:n}){t.mode==="ganache"?await t.request({method:"evm_setAccountBalance",params:[e,v(n)]}):await t.request({method:`${t.mode}_setBalance`,params:[e,v(n)]})}async function pr(t,{gasLimit:e}){await t.request({method:"evm_setBlockGasLimit",params:[v(e)]})}async function gr(t,{interval:e}){const n=t.mode==="hardhat"?e*1e3:e;await t.request({method:`${t.mode}_setBlockTimestampInterval`,params:[n]})}async function yr(t,{address:e,bytecode:n}){t.mode==="ganache"?await t.request({method:"evm_setAccountCode",params:[e,n]}):await t.request({method:`${t.mode}_setCode`,params:[e,n]})}async function xr(t,{address:e}){await t.request({method:`${t.mode}_setCoinbase`,params:[e]})}async function wr(t,{interval:e}){const n=t.mode==="hardhat"?e*1e3:e;await t.request({method:"evm_setIntervalMining",params:[n]})}async function br(t,e){await t.request({method:`${t.mode}_setLoggingEnabled`,params:[e]})}async function Er(t,{gasPrice:e}){await t.request({method:`${t.mode}_setMinGasPrice`,params:[v(e)]})}async function Ir(t,{baseFeePerGas:e}){await t.request({method:`${t.mode}_setNextBlockBaseFeePerGas`,params:[v(e)]})}async function Tr(t,{timestamp:e}){await t.request({method:"evm_setNextBlockTimestamp",params:[v(e)]})}async function Pr(t,{address:e,nonce:n}){await t.request({method:`${t.mode}_setNonce`,params:[e,v(n)]})}async function vr(t,e){await t.request({method:`${t.mode}_setRpcUrl`,params:[e]})}async function Ar(t,{address:e,index:n,value:r}){await t.request({method:`${t.mode}_setStorageAt`,params:[e,typeof n=="number"?v(n):n,r]})}async function Cr(t){return await t.request({method:"evm_snapshot"})}async function Sr(t,{address:e}){await t.request({method:`${t.mode}_stopImpersonatingAccount`,params:[e]})}function Fr({mode:t}){return e=>{const n=e.extend(()=>({mode:t}));return{dropTransaction:r=>Qn(n,r),dumpState:()=>tr(n),getAutomine:()=>er(n),getTxpoolContent:()=>nr(n),getTxpoolStatus:()=>rr(n),impersonateAccount:r=>sr(n,r),increaseTime:r=>ar(n,r),inspectTxpool:()=>or(n),loadState:r=>ir(n,r),mine:r=>cr(n,r),removeBlockTimestampInterval:()=>ur(n),reset:r=>dr(n,r),revert:r=>fr(n,r),sendUnsignedTransaction:r=>hr(n,r),setAutomine:r=>lr(n,r),setBalance:r=>mr(n,r),setBlockGasLimit:r=>pr(n,r),setBlockTimestampInterval:r=>gr(n,r),setCode:r=>yr(n,r),setCoinbase:r=>xr(n,r),setIntervalMining:r=>wr(n,r),setLoggingEnabled:r=>br(n,r),setMinGasPrice:r=>Er(n,r),setNextBlockBaseFeePerGas:r=>Ir(n,r),setNextBlockTimestamp:r=>Tr(n,r),setNonce:r=>Pr(n,r),setRpcUrl:r=>vr(n,r),setStorageAt:r=>Ar(n,r),snapshot:()=>Cr(n),stopImpersonatingAccount:r=>Sr(n,r)}}}function ds(t){const{key:e="test",name:n="Test Client",mode:r}=t;return Wt({...t,key:e,name:n,type:"testClient"}).extend(a=>({mode:r,...Fr({mode:r})(a)}))}async function _r(t,{chain:e}){const{id:n,name:r,nativeCurrency:s,rpcUrls:a,blockExplorers:o}=e;await t.request({method:"wallet_addEthereumChain",params:[{chainId:v(n),chainName:r,nativeCurrency:s,rpcUrls:a.default.http,blockExplorerUrls:o?Object.values(o).map(({url:i})=>i):void 0}]},{dedupe:!0,retryCount:0})}function Rr(t,e){const{abi:n,args:r,bytecode:s,...a}=e,o=dn({abi:n,args:r,bytecode:s});return wt(t,{...a,...a.authorizationList?{to:null}:{},data:o})}async function qr(t){var n;return((n=t.account)==null?void 0:n.type)==="local"?[t.account.address]:(await t.request({method:"eth_accounts"},{dedupe:!0})).map(r=>fn(r))}async function Ur(t,e={}){const{account:n=t.account,chainId:r}=e,s=n?_(n):void 0,a=await t.request({method:"wallet_getCapabilities",params:[s==null?void 0:s.address]}),o={};for(const[i,c]of Object.entries(a))o[Number(i)]=c;return typeof r=="number"?o[r]:o}async function Nr(t){return await t.request({method:"wallet_getPermissions"},{dedupe:!0})}async function ce(t,e){var c;const{account:n=t.account,chainId:r,nonce:s}=e;if(!n)throw new U({docsPath:"/docs/eip7702/prepareAuthorization"});const a=_(n),o=(()=>{if(e.executor)return e.executor==="self"?e.executor:_(e.executor)})(),i={address:e.contractAddress??e.address,chainId:r,nonce:s};return typeof i.chainId>"u"&&(i.chainId=((c=t.chain)==null?void 0:c.id)??await S(t,tt,"getChainId")({})),typeof i.nonce>"u"&&(i.nonce=await S(t,jt,"getTransactionCount")({address:a.address,blockTag:"pending"}),(o==="self"||o!=null&&o.address&&st(o.address,a.address))&&(i.nonce+=1)),i}async function zr(t){return(await t.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(n=>R(n))}async function Br(t,e){return t.request({method:"wallet_requestPermissions",params:[e]},{retryCount:0})}async function Lr(t,e){const{account:n=t.account,capabilities:r,chain:s=t.chain,forceAtomic:a=!1,id:o,version:i="2.0.0"}=e;if(typeof n>"u")throw new U({docsPath:"/docs/actions/wallet/sendCalls"});const c=n?_(n):null,u=e.calls.map(h=>{const f=h;return{data:f.abi?kt({abi:f.abi,functionName:f.functionName,args:f.args}):f.data,to:f.to,value:f.value?v(f.value):void 0}});try{const h=await t.request({method:"wallet_sendCalls",params:[{atomicRequired:a,calls:u,capabilities:r,chainId:v(s.id),from:c==null?void 0:c.address,id:o,version:i}]},{retryCount:0});return typeof h=="string"?{id:h}:h}catch(h){throw Yt(h,{...e,account:c,chain:e.chain})}}async function kr(t,e){const{id:n}=e;await t.request({method:"wallet_showCallsStatus",params:[n]})}async function Gr(t,e){const{account:n=t.account}=e;if(!n)throw new U({docsPath:"/docs/eip7702/signAuthorization"});const r=_(n);if(!r.signAuthorization)throw new J({docsPath:"/docs/eip7702/signAuthorization",metaMessages:["The `signAuthorization` Action does not support JSON-RPC Accounts."],type:r.type});const s=await ce(t,e);return r.signAuthorization(s)}async function Mr(t,{account:e=t.account,message:n}){if(!e)throw new U({docsPath:"/docs/actions/wallet/signMessage"});const r=_(e);if(r.signMessage)return r.signMessage({message:n});const s=typeof n=="string"?Mt(n):n.raw instanceof Uint8Array?b(n.raw):n.raw;return t.request({method:"personal_sign",params:[s,r.address]},{retryCount:0})}async function Dr(t,e){var u,h,f,l;const{account:n=t.account,chain:r=t.chain,...s}=e;if(!n)throw new U({docsPath:"/docs/actions/wallet/signTransaction"});const a=_(n);Nt({account:a,...e});const o=await S(t,tt,"getChainId")({});r!==null&&Kt({currentChainId:o,chain:r});const i=(r==null?void 0:r.formatters)||((u=t.chain)==null?void 0:u.formatters),c=((h=i==null?void 0:i.transactionRequest)==null?void 0:h.format)||pt;return a.signTransaction?a.signTransaction({...s,chainId:o},{serializer:(l=(f=t.chain)==null?void 0:f.serializers)==null?void 0:l.transaction}):await t.request({method:"eth_signTransaction",params:[{...c(s),chainId:v(o),from:a.address}]},{retryCount:0})}async function $r(t,e){const{account:n=t.account,domain:r,message:s,primaryType:a}=e;if(!n)throw new U({docsPath:"/docs/actions/wallet/signTypedData"});const o=_(n),i={EIP712Domain:hn({domain:r}),...e.types};if(ln({domain:r,message:s,primaryType:a,types:i}),o.signTypedData)return o.signTypedData({domain:r,message:s,primaryType:a,types:i});const c=mn({domain:r,message:s,primaryType:a,types:i});return t.request({method:"eth_signTypedData_v4",params:[o.address,c]},{retryCount:0})}async function Hr(t,{id:e}){await t.request({method:"wallet_switchEthereumChain",params:[{chainId:v(e)}]},{retryCount:0})}async function Or(t,e){return await t.request({method:"wallet_watchAsset",params:e},{retryCount:0})}function Vr(t){return{addChain:e=>_r(t,e),deployContract:e=>Rr(t,e),getAddresses:()=>qr(t),getCallsStatus:e=>Zt(t,e),getCapabilities:()=>Ur(t),getChainId:()=>tt(t),getPermissions:()=>Nr(t),prepareAuthorization:e=>ce(t,e),prepareTransactionRequest:e=>Bt(t,e),requestAddresses:()=>zr(t),requestPermissions:e=>Br(t,e),sendCalls:e=>Lr(t,e),sendRawTransaction:e=>Lt(t,e),sendTransaction:e=>wt(t,e),showCallsStatus:e=>kr(t,e),signAuthorization:e=>Gr(t,e),signMessage:e=>Mr(t,e),signTransaction:e=>Dr(t,e),signTypedData:e=>$r(t,e),switchChain:e=>Hr(t,e),waitForCallsStatus:e=>yn(t,e),watchAsset:e=>Or(t,e),writeContract:e=>Jt(t,e)}}function fs(t){const{key:e="wallet",name:n="Wallet Client",transport:r}=t;return Wt({...t,key:e,name:n,transport:r,type:"walletClient"}).extend(Vr)}class hs extends Error{constructor(e,n){super(n),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.code=e,this.details=n}}const lt="/docs/contract/decodeDeployData";function ls(t){const{abi:e,bytecode:n,data:r}=t;if(r===n)return{bytecode:n};const s=e.find(o=>"type"in o&&o.type==="constructor");if(!s)throw new pn({docsPath:lt});if(!("inputs"in s))throw new Ct({docsPath:lt});if(!s.inputs||s.inputs.length===0)throw new Ct({docsPath:lt});return{args:Vt(s.inputs,`0x${r.replace(n,"")}`),bytecode:n}}function ms({r:t,yParityAndS:e}){const n=nt(e),r=n[0]&128?1:0,s=n;return r===1&&(s[0]&=127),{r:t,s:G(s),yParity:r}}function ps(t){const{r:e,s:n}=xt.Signature.fromCompact(t.slice(2,130));return{r:v(e,{size:32}),yParityAndS:v(n,{size:32})}}function gs(t){const{r:e,s:n}=xt.Signature.fromCompact(t.slice(2,130)),r=+`0x${t.slice(130)}`,[s,a]=(()=>{if(r===0||r===1)return[void 0,r];if(r===27)return[BigInt(r),0];if(r===28)return[BigInt(r),1];throw new Error("Invalid yParityOrV value")})();return typeof s<"u"?{r:v(e,{size:32}),s:v(n,{size:32}),v:s,yParity:a}:{r:v(e,{size:32}),s:v(n,{size:32}),yParity:a}}async function ys(t){const{serializedTransaction:e,signature:n}=t,r=Hn(e),s=n??{r:r.r,s:r.s,v:r.v,yParity:r.yParity},a=En({...r,r:void 0,s:void 0,v:void 0,yParity:void 0,sidecars:void 0});return await rt({hash:Q(a),signature:s})}function xs(t){const{r:e,s:n,v:r,yParity:s}=t,a=Number(s??r-27n);let o=n;if(a===1){const i=nt(n);i[0]|=128,o=G(i)}return{r:e,yParityAndS:o}}function ws({r:t,yParityAndS:e}){return`0x${new xt.Signature(P(t),P(e)).toCompactHex()}`}function bs(t){const{sidecars:e,version:n}=t,r=t.to??(typeof e[0].blob=="string"?"hex":"bytes"),s=[];for(const{commitment:a}of e)s.push(gn({commitment:a,to:r,version:n}));return s}function Es(t){const e=t.to??(typeof t.blobs[0]=="string"?"hex":"bytes"),n=typeof t.blobs[0]=="string"?t.blobs.map(i=>nt(i)):t.blobs,r=n.reduce((i,c)=>i+c.length,0),s=mt(new Uint8Array(r));let a=!0;for(const i of n){const c=mt(i);for(;a&&c.position<i.length;){c.incrementPosition(1);let u=31;i.length-c.position<31&&(u=i.length-c.position);for(const h in Array.from({length:u})){const f=c.readByte();if(f===128&&!c.inspectBytes(c.remaining).includes(128)){a=!1;break}s.pushByte(f)}}}const o=s.bytes.slice(0,s.position);return e==="hex"?G(o):o}function jr({blobToKzgCommitment:t,computeBlobKzgProof:e}){return{blobToKzgCommitment:t,computeBlobKzgProof:e}}function Is(t,e){try{t.loadTrustedSetup(e)}catch(n){const r=n;if(!r.message.includes("trusted setup is already loaded"))throw r}return jr(t)}export{pn as AbiConstructorNotFoundError,Ct as AbiConstructorParamsNotFoundError,vs as AbiDecodingDataSizeInvalidError,As as AbiDecodingDataSizeTooSmallError,Cs as AbiDecodingZeroDataError,Ss as AbiEncodingArrayLengthMismatchError,Fs as AbiEncodingBytesSizeMismatchError,ze as AbiEncodingLengthMismatchError,_s as AbiErrorInputsNotFoundError,Rs as AbiErrorNotFoundError,qs as AbiErrorSignatureNotFoundError,Us as AbiEventNotFoundError,Ns as AbiEventSignatureEmptyTopicsError,zs as AbiEventSignatureNotFoundError,Bs as AbiFunctionNotFoundError,Ls as AbiFunctionOutputsNotFoundError,ks as AbiFunctionSignatureNotFoundError,Gs as AccountStateConflictError,Ms as AtomicReadyWalletRejectedUpgradeError,Ds as AtomicityNotSupportedError,q as BaseError,$s as BaseFeeScalarError,Hs as BlockNotFoundError,Os as BundleTooLargeError,Ge as BytesSizeMismatchError,Vs as CallExecutionError,js as ChainDisconnectedError,Ws as ChainDoesNotSupportContract,le as ChainMismatchError,he as ChainNotFoundError,Ks as CircularReferenceError,Ys as ClientChainNotConfiguredError,Js as ContractFunctionExecutionError,Zs as ContractFunctionRevertedError,Xs as ContractFunctionZeroDataError,Qs as CounterfactualDeploymentFailedError,ta as DecodeLogDataMismatch,ea as DecodeLogTopicsMismatch,na as DuplicateIdError,hs as EIP1193ProviderRpcError,ra as Eip1559FeesNotSupportedError,sa as EnsAvatarInvalidNftUriError,aa as EnsAvatarUnsupportedNamespaceError,oa as EnsAvatarUriResolutionError,ia as EstimateGasExecutionError,Ue as ExecutionRevertedError,yt as FeeCapTooHighError,ca as FeeCapTooLowError,ua as FeeConflictError,da as FilterTypeNotSupportedError,fa as HttpRequestError,ha as InsufficientFundsError,la as IntegerOutOfRangeError,ma as InternalRpcError,pa as IntrinsicGasTooHighError,ga as IntrinsicGasTooLowError,ya as InvalidAbiDecodingTypeError,xa as InvalidAbiEncodingTypeError,wa as InvalidAbiItemError,de as InvalidAbiParameterError,fe as InvalidAbiParametersError,ba as InvalidAbiTypeParameterError,L as InvalidAddressError,Ea as InvalidArrayError,Ia as InvalidBytesBooleanError,et as InvalidChainIdError,Jn as InvalidDecimalNumberError,Ta as InvalidDefinitionTypeError,Pa as InvalidDomainError,va as InvalidFunctionModifierError,Aa as InvalidHexBooleanError,Qe as InvalidHexValueError,Ca as InvalidInputRpcError,Ot as InvalidLegacyVError,Sa as InvalidModifierError,Fa as InvalidParameterError,_a as InvalidParamsRpcError,Ra as InvalidParenthesisError,qa as InvalidPrimaryTypeError,Ua as InvalidRequestRpcError,Na as InvalidSerializableTransactionError,H as InvalidSerializedTransactionError,on as InvalidSerializedTransactionTypeError,za as InvalidSignatureError,We as InvalidStorageKeySizeError,Ba as InvalidStructSignatureError,La as InvalidStructTypeError,ka as JsonRpcVersionUnsupportedError,Ga as LimitExceededRpcError,Ma as MaxFeePerGasTooLowError,Da as MethodNotFoundRpcError,$a as MethodNotSupportedRpcError,Ha as NonceMaxValueError,Oa as NonceTooHighError,Va as NonceTooLowError,ja as ParseRpcError,Wa as ProviderDisconnectedError,Ka as ProviderRpcError,Ya as RawContractError,Ja as ResourceNotFoundRpcError,Za as ResourceUnavailableRpcError,Xa as RpcError,Qa as RpcRequestError,to as SizeExceedsPaddingSizeError,eo as SizeOverflowError,no as SliceOffsetOutOfBoundsError,ro as SocketClosedError,so as SolidityProtectedKeywordError,ao as StateAssignmentConflictError,oo as SwitchChainError,io as TimeoutError,$e as TipAboveFeeCapError,ge as TransactionExecutionError,co as TransactionNotFoundError,uo as TransactionReceiptNotFoundError,Re as TransactionRejectedRpcError,fo as TransactionTypeNotSupportedError,ho as UnauthorizedProviderError,lo as UnknownBundleIdError,pe as UnknownNodeError,mo as UnknownRpcError,po as UnknownSignatureError,go as UnknownTypeError,yo as UnsupportedChainIdError,xo as UnsupportedNonOptionalCapabilityError,De as UnsupportedPackedAbiType,wo as UnsupportedProviderMethodError,bo as UrlRequiredError,qe as UserRejectedRequestError,xn as WaitForCallsStatusTimeoutError,Eo as WaitForTransactionReceiptTimeoutError,Io as WebSocketRequestError,Kt as assertCurrentChain,Nt as assertRequest,at as assertTransactionEIP1559,ee as assertTransactionEIP2930,ne as assertTransactionLegacy,Ye as blobsToCommitments,Ze as blobsToProofs,To as boolToBytes,Be as boolToHex,Po as bytesToBigInt,vo as bytesToBool,G as bytesToHex,Ao as bytesToNumber,Co as bytesToRlp,So as bytesToString,Wu as ccipFetch,Ku as ccipRequest,fn as checksumAddress,gn as commitmentToVersionedHash,Je as commitmentsToVersionedHashes,ws as compactSignatureToHex,ms as compactSignatureToSignature,Xe as concat,Fo as concatBytes,M as concatHex,Wt as createClient,Zn as createNonceManager,_o as createPublicClient,ds as createTestClient,Gt as createTransport,fs as createWalletClient,Zr as custom,Vt as decodeAbiParameters,ls as decodeDeployData,Ro as decodeErrorResult,qo as decodeEventLog,Uo as decodeFunctionData,No as decodeFunctionResult,zo as defineBlock,Bo as defineChain,jr as defineKzg,Lo as defineTransaction,ko as defineTransactionReceipt,Go as defineTransactionRequest,Mo as deploylessCallViaBytecodeBytecode,Do as deploylessCallViaFactoryBytecode,$o as domainSeparator,Ho as encodeAbiParameters,dn as encodeDeployData,Oo as encodeErrorResult,Vo as encodeEventTopics,kt as encodeFunctionData,jo as encodeFunctionResult,ts as encodePacked,Wo as erc1155Abi,Ko as erc20Abi,Yo as erc20Abi_bytes32,Jo as erc4626Abi,Zo as erc721Abi,Xo as ethAddress,cn as etherUnits,Qr as extractChain,Xr as fallback,Qo as formatBlock,ti as formatEther,ei as formatGwei,ni as formatLog,ri as formatTransaction,si as formatTransactionReceipt,pt as formatTransactionRequest,ai as formatUnits,Es as fromBlobs,oi as fromBytes,ii as fromHex,re as fromRlp,ci as getAbiItem,R as getAddress,ui as getChainContractAddress,Jr as getContract,es as getContractAddress,we as getContractError,Fn as getCreate2Address,Sn as getCreateAddress,di as getEventSelector,fi as getEventSignature,hi as getFunctionSelector,li as getFunctionSignature,$n as getSerializedTransactionType,Ke as getTransactionType,hn as getTypesForEIP712Domain,un as gweiUnits,mi as hashDomain,nn as hashMessage,pi as hashStruct,rn as hashTypedData,P as hexToBigInt,gi as hexToBool,nt as hexToBytes,ps as hexToCompactSignature,C as hexToNumber,yi as hexToRlp,gs as hexToSignature,xi as hexToString,wi as http,B as isAddress,st as isAddressEqual,St as isBytes,sn as isErc6492Signature,Rn as isHash,w as isHex,Q as keccak256,bi as labelhash,Ei as maxInt104,Ii as maxInt112,Ti as maxInt120,Pi as maxInt128,vi as maxInt136,Ai as maxInt144,Ci as maxInt152,Si as maxInt16,Fi as maxInt160,_i as maxInt168,Ri as maxInt176,qi as maxInt184,Ui as maxInt192,Ni as maxInt200,zi as maxInt208,Bi as maxInt216,Li as maxInt224,ki as maxInt232,Gi as maxInt24,Mi as maxInt240,Di as maxInt248,$i as maxInt256,Hi as maxInt32,Oi as maxInt40,Vi as maxInt48,ji as maxInt56,Wi as maxInt64,Ki as maxInt72,Yi as maxInt8,Ji as maxInt80,Zi as maxInt88,Xi as maxInt96,Qi as maxUint104,tc as maxUint112,ec as maxUint120,nc as maxUint128,rc as maxUint136,sc as maxUint144,ac as maxUint152,oc as maxUint16,ic as maxUint160,cc as maxUint168,uc as maxUint176,dc as maxUint184,fc as maxUint192,hc as maxUint200,lc as maxUint208,mc as maxUint216,pc as maxUint224,gc as maxUint232,yc as maxUint24,xc as maxUint240,wc as maxUint248,gt as maxUint256,bc as maxUint32,Ec as maxUint40,Ic as maxUint48,Tc as maxUint56,Pc as maxUint64,vc as maxUint72,Ac as maxUint8,Cc as maxUint80,Sc as maxUint88,Fc as maxUint96,_c as minInt104,Rc as minInt112,qc as minInt120,Uc as minInt128,Nc as minInt136,zc as minInt144,Bc as minInt152,Lc as minInt16,kc as minInt160,Gc as minInt168,Mc as minInt176,Dc as minInt184,$c as minInt192,Hc as minInt200,Oc as minInt208,Vc as minInt216,jc as minInt224,Wc as minInt232,Kc as minInt24,Yc as minInt240,Jc as minInt248,Zc as minInt256,Xc as minInt32,Qc as minInt40,tu as minInt48,eu as minInt56,nu as minInt64,ru as minInt72,su as minInt8,au as minInt80,ou as minInt88,iu as minInt96,cu as multicall3Abi,uu as namehash,us as nonceManager,du as numberToBytes,v as numberToHex,Yu as offchainLookup,Ju as offchainLookupAbiItem,Zu as offchainLookupSignature,Y as pad,fu as padBytes,At as padHex,hu as parseAbi,lu as parseAbiItem,Kr as parseAbiParameter,Yr as parseAbiParameters,ps as parseCompactSignature,os as parseErc6492Signature,is as parseEther,mu as parseEventLogs,cs as parseGwei,gs as parseSignature,Hn as parseTransaction,ie as parseUnits,pu as prepareEncodeFunctionData,gu as presignMessagePrefix,yu as publicActions,rt as recoverAddress,Mn as recoverMessageAddress,xu as recoverPublicKey,ys as recoverTransactionAddress,Dn as recoverTypedDataAddress,ns as ripemd160,wu as rpcSchema,bu as rpcTransactionType,ot as serializeAccessList,ws as serializeCompactSignature,Eu as serializeErc6492Signature,Iu as serializeSignature,En as serializeTransaction,mn as serializeTypedData,Tu as setErrorConfig,Is as setupKzg,Pu as sha256,wn as shouldThrow,bs as sidecarsToVersionedHashes,xs as signatureToCompactSignature,vu as signatureToHex,Dt as size,$t as slice,Au as sliceBytes,an as sliceHex,Cu as stringToBytes,Mt as stringToHex,Ce as stringify,Fr as testActions,Ht as toBlobSidecars,Su as toBlobs,N as toBytes,Fu as toEventHash,_u as toEventSelector,Ru as toEventSignature,qu as toFunctionHash,Uu as toFunctionSelector,Nu as toFunctionSignature,b as toHex,zu as toPrefixedMessage,z as toRlp,Bu as transactionType,$ as trim,Lu as universalSignatureValidatorAbi,ku as universalSignatureValidatorByteCode,ln as validateTypedData,rs as verifyHash,ss as verifyMessage,as as verifyTypedData,Vr as walletActions,Gu as webSocket,Mu as weiUnits,Du as withCache,$u as withRetry,Hu as withTimeout,Ou as zeroAddress,Vu as zeroHash};
