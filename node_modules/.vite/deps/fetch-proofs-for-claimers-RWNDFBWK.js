import {
  MerkleTree,
  convertQuantity,
  hashEntry
} from "./chunk-FFC732AE.js";
import "./chunk-43F4DZXD.js";
import {
  ZERO_ADDRESS,
  isNativeTokenAddress
} from "./chunk-YCZ3YGMG.js";
import "./chunk-DUYIIKDP.js";
import {
  download
} from "./chunk-ZV55Y52O.js";
import "./chunk-BEN7G6KN.js";
import "./chunk-BV5KUSOD.js";
import "./chunk-HAADYJEF.js";
import "./chunk-UEMNQLCH.js";
import "./chunk-C4WZYDZ5.js";
import "./chunk-5Q3IKOT5.js";
import "./chunk-UG7W3O5D.js";
import "./chunk-HPL7DIM2.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-PPP72TBL.js";
import "./chunk-BKJYNEUX.js";
import "./chunk-26FWGFQH.js";
import "./chunk-TSEXTBDY.js";
import "./chunk-BJ63FHMG.js";
import "./chunk-6CMZOK3K.js";
import "./chunk-HXWRQBIO.js";
import "./chunk-5UQS4U7E.js";
import "./chunk-ZLUBC7IW.js";
import "./chunk-5Q2S2L2S.js";
import "./chunk-4LB33PYO.js";
import "./chunk-HARK4W7T.js";
import "./chunk-OS7ZSSJM.js";

// node_modules/thirdweb/dist/esm/utils/extensions/drops/fetch-proofs-for-claimers.js
async function fetchProofsForClaimer(options) {
  const { contract, merkleTreeUri, claimer } = options;
  const hashEntryFn = options.hashEntry || hashEntry;
  const response = await download({
    client: contract.client,
    uri: merkleTreeUri
  });
  const merkleInfo = await response.json();
  const shardId = claimer.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();
  const uri = merkleInfo.baseUri.endsWith("/") ? merkleInfo.baseUri : `${merkleInfo.baseUri}/`;
  let shardData;
  try {
    const constructedShardUri = `${uri}${shardId}.json`;
    const shard = await download({
      client: contract.client,
      uri: constructedShardUri
    });
    shardData = await shard.json();
  } catch {
    return null;
  }
  const hashedEntries = await Promise.all(shardData.entries.map(async (entry2) => {
    return hashEntryFn({
      chain: contract.chain,
      client: contract.client,
      entry: entry2,
      tokenDecimals: options.tokenDecimals
    });
  }));
  const tree = new MerkleTree(hashedEntries);
  const entry = shardData.entries.find((i) => i.address.toLowerCase() === claimer.toLowerCase());
  if (!entry) {
    return null;
  }
  const proof = tree.getHexProof(await hashEntryFn({
    chain: contract.chain,
    client: contract.client,
    entry,
    tokenDecimals: options.tokenDecimals
  })).concat(shardData.proofs);
  const currencyAddress = entry.currencyAddress || ZERO_ADDRESS;
  const currencyDecimals = await (async () => {
    if (isNativeTokenAddress(currencyAddress) || currencyAddress === ZERO_ADDRESS) {
      return 18;
    }
    const [{ getContract }, { decimals: getDecimals }] = await Promise.all([
      import("./contract-BGG4JIGA.js"),
      import("./decimals-YMWKMD3F.js")
    ]);
    const currencyContract = getContract({
      address: currencyAddress,
      chain: contract.chain,
      client: contract.client
    });
    return await getDecimals({ contract: currencyContract });
  })();
  return {
    currency: currencyAddress,
    pricePerToken: convertQuantity({
      quantity: entry.price || "unlimited",
      tokenDecimals: currencyDecimals
    }),
    proof,
    quantityLimitPerWallet: convertQuantity({
      quantity: entry.maxClaimable || "unlimited",
      tokenDecimals: options.tokenDecimals
    })
  };
}
export {
  fetchProofsForClaimer
};
//# sourceMappingURL=fetch-proofs-for-claimers-RWNDFBWK.js.map
