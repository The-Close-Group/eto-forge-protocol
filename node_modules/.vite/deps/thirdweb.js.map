{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/hashing/sha256.ts", "../../thirdweb/src/utils/client-id.ts", "../../thirdweb/src/client/client.ts", "../../thirdweb/src/engine/index.ts", "../../@thirdweb-dev/engine/src/client/core/bodySerializer.ts", "../../@thirdweb-dev/engine/src/client/core/params.ts", "../../@thirdweb-dev/engine/src/client/core/auth.ts", "../../@thirdweb-dev/engine/src/client/core/pathSerializer.ts", "../../@thirdweb-dev/engine/src/client/client/utils.ts", "../../@thirdweb-dev/engine/src/client/client/client.ts", "../../@thirdweb-dev/engine/src/client/client.gen.ts", "../../@thirdweb-dev/engine/src/client/sdk.gen.ts", "../../@thirdweb-dev/engine/src/configure.ts", "../../thirdweb/src/engine/create-server-wallet.ts", "../../thirdweb/src/engine/get-status.ts", "../../thirdweb/src/engine/list-server-wallets.ts", "../../thirdweb/src/engine/search-transactions.ts", "../../thirdweb/src/engine/wait-for-tx-hash.ts", "../../thirdweb/src/engine/server-wallet.ts", "../../thirdweb/src/rpc/actions/eth_getBlockByHash.ts", "../../thirdweb/src/rpc/actions/eth_getTransactionByHash.ts", "../../thirdweb/src/pay/buyWithCrypto/getTransfer.ts", "../../thirdweb/src/transaction/resolve-method.ts", "../../thirdweb/src/auth/verify-typed-data.ts", "../../thirdweb/src/transaction/actions/eip7702/authorization.ts"],
  "sourcesContent": ["import { sha256 as noble_sha256 } from \"@noble/hashes/sha256\";\nimport {\n  type Hex,\n  hexToUint8Array,\n  isHex,\n  uint8ArrayToHex,\n} from \"../encoding/hex.js\";\n\ntype To = \"hex\" | \"bytes\";\n\ntype Sha256Hash<TTo extends To> =\n  | (TTo extends \"bytes\" ? Uint8Array : never)\n  | (TTo extends \"hex\" ? Hex : never);\n\n/**\n * Calculates the SHA256 hash of the given value.\n * @param value - The value to hash. It can be either a hexadecimal string or a Uint8Array.\n * @param to - (Optional) The desired output format of the hash. Defaults to 'hex'.\n * @returns The SHA256 hash of the value in the specified format.\n * @example\n * ```ts\n * import { sha256 } from \"thirdweb/utils\";\n * const hash = sha256(\"0x1234\");\n * ```\n * @utils\n */\nexport function sha256<TTo extends To = \"hex\">(\n  value: Hex | Uint8Array,\n  to?: TTo,\n): Sha256Hash<TTo> {\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? hexToUint8Array(value) : value,\n  );\n  if (to === \"bytes\") {\n    return bytes as Sha256Hash<TTo>;\n  }\n  return uint8ArrayToHex(bytes) as Sha256Hash<TTo>;\n}\n", "import { LruMap } from \"./caching/lru.js\";\nimport { stringToBytes } from \"./encoding/to-bytes.js\";\nimport { sha256 } from \"./hashing/sha256.js\";\n\nconst cache = new LruMap<string>(4096);\n\n/**\n * @param secretKey - the secret key to compute the client id from\n * @returns the 32 char hex client id\n * @internal\n */\nexport function computeClientIdFromSecretKey(secretKey: string): string {\n  if (cache.has(secretKey)) {\n    return cache.get(secretKey) as string;\n  }\n  // we slice off the leading `0x` and then take the first 32 chars\n  const cId = sha256(stringToBytes(secretKey)).slice(2, 34);\n  cache.set(secretKey, cId);\n  return cId;\n}\n", "import { computeClientIdFromSecretKey } from \"../utils/client-id.js\";\nimport { isJWT } from \"../utils/jwt/is-jwt.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\n\ntype FetchConfig = {\n  requestTimeoutMs?: number;\n  keepalive?: boolean;\n  headers?: HeadersInit;\n};\n\ntype ClientOptions = Prettify<{\n  /**\n   * The configuration options for the client.\n   */\n  config?: {\n    /**\n     * The configuration options for the RPC client.\n     */\n    rpc?: {\n      /**\n       * The configuration options for the fetch function.\n       * @default {}\n       */\n      fetch?: FetchConfig;\n      /**\n       * The maximum number of requests to batch together.\n       * @default 100\n       */\n      maxBatchSize?: number;\n      /**\n       * The maximum time to wait before sending a batch of requests.\n       * @default 0 (no timeout)\n       */\n      batchTimeoutMs?: number;\n    };\n    /**\n     * The configuration options for the storage client.\n     */\n    storage?: {\n      /**\n       * The configuration options for the fetch function.\n       * @default {}\n       */\n      fetch?: FetchConfig;\n      /**\n       * The IPFS gateway URL.\n       * @default \"https://<your_client_id>.ipfscdn.io/ipfs/<cid>\"\n       */\n      gatewayUrl?: string;\n    };\n  };\n\n  /**\n   * The team ID for thirdweb dashboard usage.\n   * @hidden\n   */\n  teamId?: string;\n}>;\n\nexport type CreateThirdwebClientOptions = Prettify<\n  (\n    | {\n        clientId: string;\n        secretKey?: string;\n      }\n    | {\n        clientId?: string;\n        secretKey: string;\n      }\n  ) &\n    ClientOptions\n>;\n\nexport type ThirdwebClient = {\n  readonly clientId: string;\n  readonly secretKey: string | undefined;\n} & Readonly<ClientOptions>;\n\n/**\n * Creates a Thirdweb client using the provided client ID (client-side) or secret key (server-side).\n *\n * Get your client ID and secret key from the Thirdweb dashboard [here](https://thirdweb.com/create-api-key).\n * **Never share your secret key with anyone.\n *\n * A client is necessary for most functions in the thirdweb SDK. It provides access to thirdweb APIs including built-in RPC, storage, and more.\n *\n * @param options - The options for creating the client.\n * @param [options.clientId] - The client ID to use for thirdweb services.\n * @param [options.secretKey] - The secret key to use for thirdweb services.\n * @returns The created Thirdweb client.\n * @throws An error if neither `clientId` nor `secretKey` is provided.\n *\n * @example\n * Create a client on the client side (client ID):\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ clientId: \"...\" });\n * ```\n *\n * Create a client on the server (secret key):\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ secretKey: \"...\" });\n * ```\n * @client\n */\nexport function createThirdwebClient(\n  options: CreateThirdwebClientOptions,\n): ThirdwebClient {\n  const { clientId, secretKey, ...rest } = options;\n\n  let realClientId: string | undefined = clientId;\n\n  if (secretKey) {\n    if (isJWT(secretKey)) {\n      // when passing a JWT as secret key we HAVE to also have a clientId\n      if (!clientId) {\n        throw new Error(\"clientId must be provided when using a JWT secretKey\");\n      }\n    } else {\n      // always PREFER the clientId if provided, only compute it from the secretKey if we don't have a clientId passed explicitly\n      realClientId = clientId ?? computeClientIdFromSecretKey(secretKey);\n    }\n  }\n\n  // only path we get here is if we have no secretKey and no clientId\n  if (!realClientId) {\n    throw new Error(\"clientId or secretKey must be provided\");\n  }\n\n  return {\n    ...rest,\n    clientId: realClientId,\n    secretKey,\n  } as const;\n}\n", "export {\n  type CreateServerWalletArgs,\n  createServerWallet,\n} from \"./create-server-wallet.js\";\nexport {\n  type ExecutionResult,\n  getTransactionStatus,\n  type RevertData,\n} from \"./get-status.js\";\nexport {\n  type GetServerWalletsArgs,\n  getServerWallets,\n} from \"./list-server-wallets.js\";\nexport {\n  type SearchTransactionsArgs,\n  searchTransactions,\n} from \"./search-transactions.js\";\nexport {\n  type ServerWallet,\n  type ServerWalletOptions,\n  serverWallet,\n} from \"./server-wallet.js\";\nexport { waitForTransactionHash } from \"./wait-for-tx-hash.js\";\n", "import type {\n\tArrayStyle,\n\tObjectStyle,\n\tSerializerOptions,\n} from \"./pathSerializer.js\";\n\nexport type QuerySerializer = (query: Record<string, unknown>) => string;\n\nexport type BodySerializer = (body: any) => any;\n\nexport interface QuerySerializerOptions {\n\tallowReserved?: boolean;\n\tarray?: SerializerOptions<ArrayStyle>;\n\tobject?: SerializerOptions<ObjectStyle>;\n}\n\nconst serializeFormDataPair = (data: FormData, key: string, value: unknown) => {\n\tif (typeof value === \"string\" || value instanceof Blob) {\n\t\tdata.append(key, value);\n\t} else {\n\t\tdata.append(key, JSON.stringify(value));\n\t}\n};\n\nconst serializeUrlSearchParamsPair = (\n\tdata: URLSearchParams,\n\tkey: string,\n\tvalue: unknown,\n) => {\n\tif (typeof value === \"string\") {\n\t\tdata.append(key, value);\n\t} else {\n\t\tdata.append(key, JSON.stringify(value));\n\t}\n};\n\nexport const formDataBodySerializer = {\n\tbodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n\t\tbody: T,\n\t) => {\n\t\tconst data = new FormData();\n\n\t\tObject.entries(body).forEach(([key, value]) => {\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue.forEach((v) => serializeFormDataPair(data, key, v));\n\t\t\t} else {\n\t\t\t\tserializeFormDataPair(data, key, value);\n\t\t\t}\n\t\t});\n\n\t\treturn data;\n\t},\n};\n\nexport const jsonBodySerializer = {\n\tbodySerializer: <T>(body: T) =>\n\t\tJSON.stringify(body, (_key, value) =>\n\t\t\ttypeof value === \"bigint\" ? value.toString() : value,\n\t\t),\n};\n\nexport const urlSearchParamsBodySerializer = {\n\tbodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n\t\tbody: T,\n\t) => {\n\t\tconst data = new URLSearchParams();\n\n\t\tObject.entries(body).forEach(([key, value]) => {\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue.forEach((v) => serializeUrlSearchParamsPair(data, key, v));\n\t\t\t} else {\n\t\t\t\tserializeUrlSearchParamsPair(data, key, value);\n\t\t\t}\n\t\t});\n\n\t\treturn data.toString();\n\t},\n};\n", "type Slot = \"body\" | \"headers\" | \"path\" | \"query\";\n\nexport type Field =\n\t| {\n\t\t\tin: Exclude<Slot, \"body\">;\n\t\t\tkey: string;\n\t\t\tmap?: string;\n\t  }\n\t| {\n\t\t\tin: Extract<Slot, \"body\">;\n\t\t\tkey?: string;\n\t\t\tmap?: string;\n\t  };\n\nexport interface Fields {\n\tallowExtra?: Partial<Record<Slot, boolean>>;\n\targs?: ReadonlyArray<Field>;\n}\n\nexport type FieldsConfig = ReadonlyArray<Field | Fields>;\n\nconst extraPrefixesMap: Record<string, Slot> = {\n\t$body_: \"body\",\n\t$headers_: \"headers\",\n\t$path_: \"path\",\n\t$query_: \"query\",\n};\nconst extraPrefixes = Object.entries(extraPrefixesMap);\n\ntype KeyMap = Map<\n\tstring,\n\t{\n\t\tin: Slot;\n\t\tmap?: string;\n\t}\n>;\n\nconst buildKeyMap = (fields: FieldsConfig, map?: KeyMap): KeyMap => {\n\tif (!map) {\n\t\tmap = new Map();\n\t}\n\n\tfor (const config of fields) {\n\t\tif (\"in\" in config) {\n\t\t\tif (config.key) {\n\t\t\t\tmap.set(config.key, {\n\t\t\t\t\tin: config.in,\n\t\t\t\t\tmap: config.map,\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (config.args) {\n\t\t\tbuildKeyMap(config.args, map);\n\t\t}\n\t}\n\n\treturn map;\n};\n\ninterface Params {\n\tbody: unknown;\n\theaders: Record<string, unknown>;\n\tpath: Record<string, unknown>;\n\tquery: Record<string, unknown>;\n}\n\nconst stripEmptySlots = (params: Params) => {\n\tfor (const [slot, value] of Object.entries(params)) {\n\t\tif (value && typeof value === \"object\" && !Object.keys(value).length) {\n\t\t\tdelete params[slot as Slot];\n\t\t}\n\t}\n};\n\nexport const buildClientParams = (\n\targs: ReadonlyArray<unknown>,\n\tfields: FieldsConfig,\n) => {\n\tconst params: Params = {\n\t\tbody: {},\n\t\theaders: {},\n\t\tpath: {},\n\t\tquery: {},\n\t};\n\n\tconst map = buildKeyMap(fields);\n\n\tlet config: FieldsConfig[number] | undefined;\n\n\tfor (const [index, arg] of args.entries()) {\n\t\tif (fields[index]) {\n\t\t\tconfig = fields[index];\n\t\t}\n\n\t\tif (!config) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\"in\" in config) {\n\t\t\tif (config.key) {\n\t\t\t\tconst field = map.get(config.key)!;\n\t\t\t\tconst name = field.map || config.key;\n\t\t\t\t(params[field.in] as Record<string, unknown>)[name] = arg;\n\t\t\t} else {\n\t\t\t\tparams.body = arg;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [key, value] of Object.entries(arg ?? {})) {\n\t\t\t\tconst field = map.get(key);\n\n\t\t\t\tif (field) {\n\t\t\t\t\tconst name = field.map || key;\n\t\t\t\t\t(params[field.in] as Record<string, unknown>)[name] = value;\n\t\t\t\t} else {\n\t\t\t\t\tconst extra = extraPrefixes.find(([prefix]) =>\n\t\t\t\t\t\tkey.startsWith(prefix),\n\t\t\t\t\t);\n\n\t\t\t\t\tif (extra) {\n\t\t\t\t\t\tconst [prefix, slot] = extra;\n\t\t\t\t\t\t(params[slot] as Record<string, unknown>)[\n\t\t\t\t\t\t\tkey.slice(prefix.length)\n\t\t\t\t\t\t] = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const [slot, allowed] of Object.entries(\n\t\t\t\t\t\t\tconfig.allowExtra ?? {},\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tif (allowed) {\n\t\t\t\t\t\t\t\t(params[slot as Slot] as Record<string, unknown>)[key] = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstripEmptySlots(params);\n\n\treturn params;\n};\n", "export type AuthToken = string | undefined;\n\nexport interface Auth {\n\t/**\n\t * Which part of the request do we use to send the auth?\n\t *\n\t * @default 'header'\n\t */\n\tin?: \"header\" | \"query\" | \"cookie\";\n\t/**\n\t * Header or query parameter name.\n\t *\n\t * @default 'Authorization'\n\t */\n\tname?: string;\n\tscheme?: \"basic\" | \"bearer\";\n\ttype: \"apiKey\" | \"http\";\n}\n\nexport const getAuthToken = async (\n\tauth: Auth,\n\tcallback: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken,\n): Promise<string | undefined> => {\n\tconst token =\n\t\ttypeof callback === \"function\" ? await callback(auth) : callback;\n\n\tif (!token) {\n\t\treturn;\n\t}\n\n\tif (auth.scheme === \"bearer\") {\n\t\treturn `Bearer ${token}`;\n\t}\n\n\tif (auth.scheme === \"basic\") {\n\t\treturn `Basic ${btoa(token)}`;\n\t}\n\n\treturn token;\n};\n", "interface SerializeOptions<T>\n\textends SerializePrimitiveOptions,\n\t\tSerializerOptions<T> {}\n\ninterface SerializePrimitiveOptions {\n\tallowReserved?: boolean;\n\tname: string;\n}\n\nexport interface SerializerOptions<T> {\n\t/**\n\t * @default true\n\t */\n\texplode: boolean;\n\tstyle: T;\n}\n\nexport type ArrayStyle = \"form\" | \"spaceDelimited\" | \"pipeDelimited\";\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype MatrixStyle = \"label\" | \"matrix\" | \"simple\";\nexport type ObjectStyle = \"form\" | \"deepObject\";\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n\tvalue: string;\n}\n\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\n\tswitch (style) {\n\t\tcase \"label\":\n\t\t\treturn \".\";\n\t\tcase \"matrix\":\n\t\t\treturn \";\";\n\t\tcase \"simple\":\n\t\t\treturn \",\";\n\t\tdefault:\n\t\t\treturn \"&\";\n\t}\n};\n\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n\tswitch (style) {\n\t\tcase \"form\":\n\t\t\treturn \",\";\n\t\tcase \"pipeDelimited\":\n\t\t\treturn \"|\";\n\t\tcase \"spaceDelimited\":\n\t\t\treturn \"%20\";\n\t\tdefault:\n\t\t\treturn \",\";\n\t}\n};\n\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n\tswitch (style) {\n\t\tcase \"label\":\n\t\t\treturn \".\";\n\t\tcase \"matrix\":\n\t\t\treturn \";\";\n\t\tcase \"simple\":\n\t\t\treturn \",\";\n\t\tdefault:\n\t\t\treturn \"&\";\n\t}\n};\n\nexport const serializeArrayParam = ({\n\tallowReserved,\n\texplode,\n\tname,\n\tstyle,\n\tvalue,\n}: SerializeOptions<ArraySeparatorStyle> & {\n\tvalue: unknown[];\n}) => {\n\tif (!explode) {\n\t\tconst joinedValues = (\n\t\t\tallowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n\t\t).join(separatorArrayNoExplode(style));\n\t\tswitch (style) {\n\t\t\tcase \"label\":\n\t\t\t\treturn `.${joinedValues}`;\n\t\t\tcase \"matrix\":\n\t\t\t\treturn `;${name}=${joinedValues}`;\n\t\t\tcase \"simple\":\n\t\t\t\treturn joinedValues;\n\t\t\tdefault:\n\t\t\t\treturn `${name}=${joinedValues}`;\n\t\t}\n\t}\n\n\tconst separator = separatorArrayExplode(style);\n\tconst joinedValues = value\n\t\t.map((v) => {\n\t\t\tif (style === \"label\" || style === \"simple\") {\n\t\t\t\treturn allowReserved ? v : encodeURIComponent(v as string);\n\t\t\t}\n\n\t\t\treturn serializePrimitiveParam({\n\t\t\t\tallowReserved,\n\t\t\t\tname,\n\t\t\t\tvalue: v as string,\n\t\t\t});\n\t\t})\n\t\t.join(separator);\n\treturn style === \"label\" || style === \"matrix\"\n\t\t? separator + joinedValues\n\t\t: joinedValues;\n};\n\nexport const serializePrimitiveParam = ({\n\tallowReserved,\n\tname,\n\tvalue,\n}: SerializePrimitiveParam) => {\n\tif (value === undefined || value === null) {\n\t\treturn \"\";\n\t}\n\n\tif (typeof value === \"object\") {\n\t\tthrow new Error(\n\t\t\t\"Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.\",\n\t\t);\n\t}\n\n\treturn `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nexport const serializeObjectParam = ({\n\tallowReserved,\n\texplode,\n\tname,\n\tstyle,\n\tvalue,\n\tvalueOnly,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n\tvalue: Record<string, unknown> | Date;\n\tvalueOnly?: boolean;\n}) => {\n\tif (value instanceof Date) {\n\t\treturn valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;\n\t}\n\n\tif (style !== \"deepObject\" && !explode) {\n\t\tlet values: string[] = [];\n\t\tObject.entries(value).forEach(([key, v]) => {\n\t\t\tvalues = [\n\t\t\t\t...values,\n\t\t\t\tkey,\n\t\t\t\tallowReserved ? (v as string) : encodeURIComponent(v as string),\n\t\t\t];\n\t\t});\n\t\tconst joinedValues = values.join(\",\");\n\t\tswitch (style) {\n\t\t\tcase \"form\":\n\t\t\t\treturn `${name}=${joinedValues}`;\n\t\t\tcase \"label\":\n\t\t\t\treturn `.${joinedValues}`;\n\t\t\tcase \"matrix\":\n\t\t\t\treturn `;${name}=${joinedValues}`;\n\t\t\tdefault:\n\t\t\t\treturn joinedValues;\n\t\t}\n\t}\n\n\tconst separator = separatorObjectExplode(style);\n\tconst joinedValues = Object.entries(value)\n\t\t.map(([key, v]) =>\n\t\t\tserializePrimitiveParam({\n\t\t\t\tallowReserved,\n\t\t\t\tname: style === \"deepObject\" ? `${name}[${key}]` : key,\n\t\t\t\tvalue: v as string,\n\t\t\t}),\n\t\t)\n\t\t.join(separator);\n\treturn style === \"label\" || style === \"matrix\"\n\t\t? separator + joinedValues\n\t\t: joinedValues;\n};\n", "import { getAuthToken } from \"../core/auth.js\";\nimport type {\n\tQuerySerializer,\n\tQuerySerializerOptions,\n} from \"../core/bodySerializer.js\";\nimport { jsonBodySerializer } from \"../core/bodySerializer.js\";\nimport {\n\tserializeArrayParam,\n\tserializeObjectParam,\n\tserializePrimitiveParam,\n} from \"../core/pathSerializer.js\";\nimport type { Client, ClientOptions, Config, RequestOptions } from \"./types.js\";\n\ninterface PathSerializer {\n\tpath: Record<string, unknown>;\n\turl: string;\n}\n\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\ntype ArrayStyle = \"form\" | \"spaceDelimited\" | \"pipeDelimited\";\ntype MatrixStyle = \"label\" | \"matrix\" | \"simple\";\ntype ArraySeparatorStyle = ArrayStyle | MatrixStyle;\n\nconst defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\n\tlet url = _url;\n\tconst matches = _url.match(PATH_PARAM_RE);\n\tif (matches) {\n\t\tfor (const match of matches) {\n\t\t\tlet explode = false;\n\t\t\tlet name = match.substring(1, match.length - 1);\n\t\t\tlet style: ArraySeparatorStyle = \"simple\";\n\n\t\t\tif (name.endsWith(\"*\")) {\n\t\t\t\texplode = true;\n\t\t\t\tname = name.substring(0, name.length - 1);\n\t\t\t}\n\n\t\t\tif (name.startsWith(\".\")) {\n\t\t\t\tname = name.substring(1);\n\t\t\t\tstyle = \"label\";\n\t\t\t} else if (name.startsWith(\";\")) {\n\t\t\t\tname = name.substring(1);\n\t\t\t\tstyle = \"matrix\";\n\t\t\t}\n\n\t\t\tconst value = path[name];\n\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\turl = url.replace(\n\t\t\t\t\tmatch,\n\t\t\t\t\tserializeArrayParam({ explode, name, style, value }),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (typeof value === \"object\") {\n\t\t\t\turl = url.replace(\n\t\t\t\t\tmatch,\n\t\t\t\t\tserializeObjectParam({\n\t\t\t\t\t\texplode,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tstyle,\n\t\t\t\t\t\tvalue: value as Record<string, unknown>,\n\t\t\t\t\t\tvalueOnly: true,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (style === \"matrix\") {\n\t\t\t\turl = url.replace(\n\t\t\t\t\tmatch,\n\t\t\t\t\t`;${serializePrimitiveParam({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tvalue: value as string,\n\t\t\t\t\t})}`,\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst replaceValue = encodeURIComponent(\n\t\t\t\tstyle === \"label\" ? `.${value as string}` : (value as string),\n\t\t\t);\n\t\t\turl = url.replace(match, replaceValue);\n\t\t}\n\t}\n\treturn url;\n};\n\nexport const createQuerySerializer = <T = unknown>({\n\tallowReserved,\n\tarray,\n\tobject,\n}: QuerySerializerOptions = {}) => {\n\tconst querySerializer = (queryParams: T) => {\n\t\tconst search: string[] = [];\n\t\tif (queryParams && typeof queryParams === \"object\") {\n\t\t\tfor (const name in queryParams) {\n\t\t\t\tconst value = queryParams[name];\n\n\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tconst serializedArray = serializeArrayParam({\n\t\t\t\t\t\tallowReserved,\n\t\t\t\t\t\texplode: true,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tstyle: \"form\",\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t...array,\n\t\t\t\t\t});\n\t\t\t\t\tif (serializedArray) search.push(serializedArray);\n\t\t\t\t} else if (typeof value === \"object\") {\n\t\t\t\t\tconst serializedObject = serializeObjectParam({\n\t\t\t\t\t\tallowReserved,\n\t\t\t\t\t\texplode: true,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tstyle: \"deepObject\",\n\t\t\t\t\t\tvalue: value as Record<string, unknown>,\n\t\t\t\t\t\t...object,\n\t\t\t\t\t});\n\t\t\t\t\tif (serializedObject) search.push(serializedObject);\n\t\t\t\t} else {\n\t\t\t\t\tconst serializedPrimitive = serializePrimitiveParam({\n\t\t\t\t\t\tallowReserved,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tvalue: value as string,\n\t\t\t\t\t});\n\t\t\t\t\tif (serializedPrimitive) search.push(serializedPrimitive);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn search.join(\"&\");\n\t};\n\treturn querySerializer;\n};\n\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = (\n\tcontentType: string | null,\n): Exclude<Config[\"parseAs\"], \"auto\"> => {\n\tif (!contentType) {\n\t\t// If no Content-Type header is provided, the best we can do is return the raw response body,\n\t\t// which is effectively the same as the 'stream' option.\n\t\treturn \"stream\";\n\t}\n\n\tconst cleanContent = contentType.split(\";\")[0]?.trim();\n\n\tif (!cleanContent) {\n\t\treturn;\n\t}\n\n\tif (\n\t\tcleanContent.startsWith(\"application/json\") ||\n\t\tcleanContent.endsWith(\"+json\")\n\t) {\n\t\treturn \"json\";\n\t}\n\n\tif (cleanContent === \"multipart/form-data\") {\n\t\treturn \"formData\";\n\t}\n\n\tif (\n\t\t[\"application/\", \"audio/\", \"image/\", \"video/\"].some((type) =>\n\t\t\tcleanContent.startsWith(type),\n\t\t)\n\t) {\n\t\treturn \"blob\";\n\t}\n\n\tif (cleanContent.startsWith(\"text/\")) {\n\t\treturn \"text\";\n\t}\n\n\treturn;\n};\n\nexport const setAuthParams = async ({\n\tsecurity,\n\t...options\n}: Pick<Required<RequestOptions>, \"security\"> &\n\tPick<RequestOptions, \"auth\" | \"query\"> & {\n\t\theaders: Headers;\n\t}) => {\n\tfor (const auth of security) {\n\t\tconst token = await getAuthToken(auth, options.auth);\n\n\t\tif (!token) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst name = auth.name ?? \"Authorization\";\n\n\t\tswitch (auth.in) {\n\t\t\tcase \"query\":\n\t\t\t\tif (!options.query) {\n\t\t\t\t\toptions.query = {};\n\t\t\t\t}\n\t\t\t\toptions.query[name] = token;\n\t\t\t\tbreak;\n\t\t\tcase \"cookie\":\n\t\t\t\toptions.headers.append(\"Cookie\", `${name}=${token}`);\n\t\t\t\tbreak;\n\t\t\tcase \"header\":\n\t\t\tdefault:\n\t\t\t\toptions.headers.set(name, token);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn;\n\t}\n};\n\nexport const buildUrl: Client[\"buildUrl\"] = (options) => {\n\tconst url = getUrl({\n\t\tbaseUrl: options.baseUrl as string,\n\t\tpath: options.path,\n\t\tquery: options.query,\n\t\tquerySerializer:\n\t\t\ttypeof options.querySerializer === \"function\"\n\t\t\t\t? options.querySerializer\n\t\t\t\t: createQuerySerializer(options.querySerializer),\n\t\turl: options.url,\n\t});\n\treturn url;\n};\n\nexport const getUrl = ({\n\tbaseUrl,\n\tpath,\n\tquery,\n\tquerySerializer,\n\turl: _url,\n}: {\n\tbaseUrl?: string;\n\tpath?: Record<string, unknown>;\n\tquery?: Record<string, unknown>;\n\tquerySerializer: QuerySerializer;\n\turl: string;\n}) => {\n\tconst pathUrl = _url.startsWith(\"/\") ? _url : `/${_url}`;\n\tlet url = (baseUrl ?? \"\") + pathUrl;\n\tif (path) {\n\t\turl = defaultPathSerializer({ path, url });\n\t}\n\tlet search = query ? querySerializer(query) : \"\";\n\tif (search.startsWith(\"?\")) {\n\t\tsearch = search.substring(1);\n\t}\n\tif (search) {\n\t\turl += `?${search}`;\n\t}\n\treturn url;\n};\n\nexport const mergeConfigs = (a: Config, b: Config): Config => {\n\tconst config = { ...a, ...b };\n\tif (config.baseUrl?.endsWith(\"/\")) {\n\t\tconfig.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n\t}\n\tconfig.headers = mergeHeaders(a.headers, b.headers);\n\treturn config;\n};\n\nexport const mergeHeaders = (\n\t...headers: Array<Required<Config>[\"headers\"] | undefined>\n): Headers => {\n\tconst mergedHeaders = new Headers();\n\tfor (const header of headers) {\n\t\tif (!header || typeof header !== \"object\") {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst iterator =\n\t\t\theader instanceof Headers ? header.entries() : Object.entries(header);\n\n\t\tfor (const [key, value] of iterator) {\n\t\t\tif (value === null) {\n\t\t\t\tmergedHeaders.delete(key);\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tfor (const v of value) {\n\t\t\t\t\tmergedHeaders.append(key, v as string);\n\t\t\t\t}\n\t\t\t} else if (value !== undefined) {\n\t\t\t\t// assume object headers are meant to be JSON stringified, i.e. their\n\t\t\t\t// content value in OpenAPI specification is 'application/json'\n\t\t\t\tmergedHeaders.set(\n\t\t\t\t\tkey,\n\t\t\t\t\ttypeof value === \"object\" ? JSON.stringify(value) : (value as string),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\treturn mergedHeaders;\n};\n\ntype ErrInterceptor<Err, Res, Req, Options> = (\n\terror: Err,\n\tresponse: Res,\n\trequest: Req,\n\toptions: Options,\n) => Err | Promise<Err>;\n\ntype ReqInterceptor<Req, Options> = (\n\trequest: Req,\n\toptions: Options,\n) => Req | Promise<Req>;\n\ntype ResInterceptor<Res, Req, Options> = (\n\tresponse: Res,\n\trequest: Req,\n\toptions: Options,\n) => Res | Promise<Res>;\n\nclass Interceptors<Interceptor> {\n\t_fns: (Interceptor | null)[];\n\n\tconstructor() {\n\t\tthis._fns = [];\n\t}\n\n\tclear() {\n\t\tthis._fns = [];\n\t}\n\n\tgetInterceptorIndex(id: number | Interceptor): number {\n\t\tif (typeof id === \"number\") {\n\t\t\treturn this._fns[id] ? id : -1;\n\t\t} else {\n\t\t\treturn this._fns.indexOf(id);\n\t\t}\n\t}\n\texists(id: number | Interceptor) {\n\t\tconst index = this.getInterceptorIndex(id);\n\t\treturn !!this._fns[index];\n\t}\n\n\teject(id: number | Interceptor) {\n\t\tconst index = this.getInterceptorIndex(id);\n\t\tif (this._fns[index]) {\n\t\t\tthis._fns[index] = null;\n\t\t}\n\t}\n\n\tupdate(id: number | Interceptor, fn: Interceptor) {\n\t\tconst index = this.getInterceptorIndex(id);\n\t\tif (this._fns[index]) {\n\t\t\tthis._fns[index] = fn;\n\t\t\treturn id;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tuse(fn: Interceptor) {\n\t\tthis._fns = [...this._fns, fn];\n\t\treturn this._fns.length - 1;\n\t}\n}\n\n// `createInterceptors()` response, meant for external use as it does not\n// expose internals\nexport interface Middleware<Req, Res, Err, Options> {\n\terror: Pick<\n\t\tInterceptors<ErrInterceptor<Err, Res, Req, Options>>,\n\t\t\"eject\" | \"use\"\n\t>;\n\trequest: Pick<Interceptors<ReqInterceptor<Req, Options>>, \"eject\" | \"use\">;\n\tresponse: Pick<\n\t\tInterceptors<ResInterceptor<Res, Req, Options>>,\n\t\t\"eject\" | \"use\"\n\t>;\n}\n\n// do not add `Middleware` as return type so we can use _fns internally\nexport const createInterceptors = <Req, Res, Err, Options>() => ({\n\terror: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\n\trequest: new Interceptors<ReqInterceptor<Req, Options>>(),\n\tresponse: new Interceptors<ResInterceptor<Res, Req, Options>>(),\n});\n\nconst defaultQuerySerializer = createQuerySerializer({\n\tallowReserved: false,\n\tarray: {\n\t\texplode: true,\n\t\tstyle: \"form\",\n\t},\n\tobject: {\n\t\texplode: true,\n\t\tstyle: \"deepObject\",\n\t},\n});\n\nconst defaultHeaders = {\n\t\"Content-Type\": \"application/json\",\n};\n\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\n\toverride: Config<Omit<ClientOptions, keyof T> & T> = {},\n): Config<Omit<ClientOptions, keyof T> & T> => ({\n\t...jsonBodySerializer,\n\theaders: defaultHeaders,\n\tparseAs: \"auto\",\n\tquerySerializer: defaultQuerySerializer,\n\t...override,\n});\n", "import type { Client, Config, RequestOptions } from \"./types.js\";\nimport {\n\tbuildUrl,\n\tcreateConfig,\n\tcreateInterceptors,\n\tgetParseAs,\n\tmergeConfigs,\n\tmergeHeaders,\n\tsetAuthParams,\n} from \"./utils.js\";\n\ntype ReqInit = Omit<RequestInit, \"body\" | \"headers\"> & {\n\tbody?: any;\n\theaders: ReturnType<typeof mergeHeaders>;\n};\n\nexport const createClient = (config: Config = {}): Client => {\n\tlet _config = mergeConfigs(createConfig(), config);\n\n\tconst getConfig = (): Config => ({ ..._config });\n\n\tconst setConfig = (config: Config): Config => {\n\t\t_config = mergeConfigs(_config, config);\n\t\treturn getConfig();\n\t};\n\n\tconst interceptors = createInterceptors<\n\t\tRequest,\n\t\tResponse,\n\t\tunknown,\n\t\tRequestOptions\n\t>();\n\n\tconst request: Client[\"request\"] = async (options) => {\n\t\tconst opts = {\n\t\t\t..._config,\n\t\t\t...options,\n\t\t\tfetch: options.fetch ?? _config.fetch ?? globalThis.fetch,\n\t\t\theaders: mergeHeaders(_config.headers, options.headers),\n\t\t};\n\n\t\tif (opts.security) {\n\t\t\tawait setAuthParams({\n\t\t\t\t...opts,\n\t\t\t\tsecurity: opts.security,\n\t\t\t});\n\t\t}\n\n\t\tif (opts.body && opts.bodySerializer) {\n\t\t\topts.body = opts.bodySerializer(opts.body);\n\t\t}\n\n\t\t// remove Content-Type header if body is empty to avoid sending invalid requests\n\t\tif (opts.body === undefined || opts.body === \"\") {\n\t\t\topts.headers.delete(\"Content-Type\");\n\t\t}\n\n\t\tconst url = buildUrl(opts);\n\t\tconst requestInit: ReqInit = {\n\t\t\tredirect: \"follow\",\n\t\t\t...opts,\n\t\t};\n\n\t\tlet request = new Request(url, requestInit);\n\n\t\tfor (const fn of interceptors.request._fns) {\n\t\t\tif (fn) {\n\t\t\t\trequest = await fn(request, opts);\n\t\t\t}\n\t\t}\n\n\t\t// fetch must be assigned here, otherwise it would throw the error:\n\t\t// TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\n\t\tconst _fetch = opts.fetch!;\n\t\tlet response = await _fetch(request);\n\n\t\tfor (const fn of interceptors.response._fns) {\n\t\t\tif (fn) {\n\t\t\t\tresponse = await fn(response, request, opts);\n\t\t\t}\n\t\t}\n\n\t\tconst result = {\n\t\t\trequest,\n\t\t\tresponse,\n\t\t};\n\n\t\tif (response.ok) {\n\t\t\tif (\n\t\t\t\tresponse.status === 204 ||\n\t\t\t\tresponse.headers.get(\"Content-Length\") === \"0\"\n\t\t\t) {\n\t\t\t\treturn opts.responseStyle === \"data\"\n\t\t\t\t\t? {}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tdata: {},\n\t\t\t\t\t\t\t...result,\n\t\t\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst parseAs =\n\t\t\t\t(opts.parseAs === \"auto\"\n\t\t\t\t\t? getParseAs(response.headers.get(\"Content-Type\"))\n\t\t\t\t\t: opts.parseAs) ?? \"json\";\n\n\t\t\tlet data: any;\n\t\t\tswitch (parseAs) {\n\t\t\t\tcase \"arrayBuffer\":\n\t\t\t\tcase \"blob\":\n\t\t\t\tcase \"formData\":\n\t\t\t\tcase \"json\":\n\t\t\t\tcase \"text\":\n\t\t\t\t\tdata = await response[parseAs]();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"stream\":\n\t\t\t\t\treturn opts.responseStyle === \"data\"\n\t\t\t\t\t\t? response.body\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tdata: response.body,\n\t\t\t\t\t\t\t\t...result,\n\t\t\t\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (parseAs === \"json\") {\n\t\t\t\tif (opts.responseValidator) {\n\t\t\t\t\tawait opts.responseValidator(data);\n\t\t\t\t}\n\n\t\t\t\tif (opts.responseTransformer) {\n\t\t\t\t\tdata = await opts.responseTransformer(data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn opts.responseStyle === \"data\"\n\t\t\t\t? data\n\t\t\t\t: {\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\t...result,\n\t\t\t\t\t};\n\t\t}\n\n\t\tlet error = await response.text();\n\n\t\ttry {\n\t\t\terror = JSON.parse(error);\n\t\t} catch {\n\t\t\t// noop\n\t\t}\n\n\t\tlet finalError = error;\n\n\t\tfor (const fn of interceptors.error._fns) {\n\t\t\tif (fn) {\n\t\t\t\tfinalError = (await fn(error, response, request, opts)) as string;\n\t\t\t}\n\t\t}\n\n\t\tfinalError = finalError || ({} as string);\n\n\t\tif (opts.throwOnError) {\n\t\t\tthrow finalError;\n\t\t}\n\n\t\t// TODO: we probably want to return error and improve types\n\t\treturn opts.responseStyle === \"data\"\n\t\t\t? undefined\n\t\t\t: {\n\t\t\t\t\terror: finalError,\n\t\t\t\t\t...result,\n\t\t\t\t};\n\t};\n\n\treturn {\n\t\tbuildUrl,\n\t\tconnect: (options) => request({ ...options, method: \"CONNECT\" }),\n\t\tdelete: (options) => request({ ...options, method: \"DELETE\" }),\n\t\tget: (options) => request({ ...options, method: \"GET\" }),\n\t\tgetConfig,\n\t\thead: (options) => request({ ...options, method: \"HEAD\" }),\n\t\tinterceptors,\n\t\toptions: (options) => request({ ...options, method: \"OPTIONS\" }),\n\t\tpatch: (options) => request({ ...options, method: \"PATCH\" }),\n\t\tpost: (options) => request({ ...options, method: \"POST\" }),\n\t\tput: (options) => request({ ...options, method: \"PUT\" }),\n\t\trequest,\n\t\tsetConfig,\n\t\ttrace: (options) => request({ ...options, method: \"TRACE\" }),\n\t};\n};\n", "// This file is auto-generated by @hey-api/openapi-ts\n\nimport {\n\ttype Config,\n\tcreateClient,\n\tcreateConfig,\n\ttype ClientOptions as DefaultClientOptions,\n} from \"./client/index.js\";\nimport type { ClientOptions } from \"./types.gen.js\";\n\n/**\n * The `createClientConfig()` function will be called on client initialization\n * and the returned object will become the client's initial configuration.\n *\n * You may want to initialize your client this way instead of calling\n * `setConfig()`. This is useful for example if you're using Next.js\n * to ensure your client always has the correct values.\n */\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> =\n\t(\n\t\toverride?: Config<DefaultClientOptions & T>,\n\t) => Config<Required<DefaultClientOptions> & T>;\n\nexport const client = createClient(\n\tcreateConfig<ClientOptions>({\n\t\tbaseUrl: \"https://engine.thirdweb.com\",\n\t}),\n);\n", "// This file is auto-generated by @hey-api/openapi-ts\n\nimport type {\n\tClient,\n\tOptions as ClientOptions,\n\tTDataShape,\n} from \"./client/index.js\";\nimport { client as _heyApiClient } from \"./client.gen.js\";\nimport type {\n\tCancelTransactionData,\n\tCancelTransactionResponses,\n\tCreateAccountData,\n\tCreateAccountResponses,\n\tEncodeContractData,\n\tEncodeContractResponses,\n\tGetActivityLogsData,\n\tGetActivityLogsErrors,\n\tGetActivityLogsResponses,\n\tGetTransactionAnalyticsData,\n\tGetTransactionAnalyticsResponses,\n\tGetTransactionAnalyticsSummaryData,\n\tGetTransactionAnalyticsSummaryErrors,\n\tGetTransactionAnalyticsSummaryResponses,\n\tGetTransactionsData,\n\tGetTransactionsResponses,\n\tListAccountsData,\n\tListAccountsResponses,\n\tReadContractData,\n\tReadContractResponses,\n\tSearchActivityLogsData,\n\tSearchActivityLogsErrors,\n\tSearchActivityLogsResponses,\n\tSearchTransactionsData,\n\tSearchTransactionsResponses,\n\tSendTransactionData,\n\tSendTransactionResponses,\n\tSignMessageData,\n\tSignMessageResponses,\n\tSignTypedDataData,\n\tSignTypedDataResponses,\n\tWriteContractData,\n\tWriteContractResponses,\n} from \"./types.gen.js\";\n\nexport type Options<\n\tTData extends TDataShape = TDataShape,\n\tThrowOnError extends boolean = boolean,\n> = ClientOptions<TData, ThrowOnError> & {\n\t/**\n\t * You can provide a client instance returned by `createClient()` instead of\n\t * individual options. This might be also useful if you want to implement a\n\t * custom client.\n\t */\n\tclient?: Client;\n\t/**\n\t * You can pass arbitrary values through the `meta` object. This can be\n\t * used to access values that aren't defined as part of the SDK function.\n\t */\n\tmeta?: Record<string, unknown>;\n};\n\n/**\n * Write Contract\n * Call a contract function with a transaction\n */\nexport const writeContract = <ThrowOnError extends boolean = false>(\n\toptions: Options<WriteContractData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tWriteContractResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/write/contract\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Write Transaction\n * Execute raw transactions\n */\nexport const sendTransaction = <ThrowOnError extends boolean = false>(\n\toptions: Options<SendTransactionData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tSendTransactionResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/write/transaction\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Sign Message\n * Sign messages using either EOA or Smart Account\n */\nexport const signMessage = <ThrowOnError extends boolean = false>(\n\toptions: Options<SignMessageData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tSignMessageResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/sign/message\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Sign Typed Data\n * Sign EIP-712 typed data using either EOA or Smart Account\n */\nexport const signTypedData = <ThrowOnError extends boolean = false>(\n\toptions: Options<SignTypedDataData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tSignTypedDataResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/sign/typed-data\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Read Contract\n * Read from multiple smart contracts using multicall\n */\nexport const readContract = <ThrowOnError extends boolean = false>(\n\toptions: Options<ReadContractData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tReadContractResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/read/contract\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Encode Contract\n * Encode contract function calls without execution\n */\nexport const encodeContract = <ThrowOnError extends boolean = false>(\n\toptions: Options<EncodeContractData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tEncodeContractResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/encode/contract\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Cancel Transaction\n * Attempt to cancel a queued transaction. Transactions that have been sent and are waiting for mine cannot be cancelled.\n */\nexport const cancelTransaction = <ThrowOnError extends boolean = false>(\n\toptions: Options<CancelTransactionData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tCancelTransactionResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/{id}/cancel\",\n\t\t...options,\n\t});\n};\n\n/**\n * List Server Wallets\n * List all engine server wallets for the current project. Returns an array of EOA addresses with their corresponding predicted smart account addresses.\n */\nexport const listAccounts = <ThrowOnError extends boolean = false>(\n\toptions?: Options<ListAccountsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).get<\n\t\tListAccountsResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/accounts\",\n\t\t...options,\n\t});\n};\n\n/**\n * Create Server Wallet\n * Create a new engine server wallet. This is a helper route for creating a new EOA with your KMS provider, provided as a convenient alternative to creating an EOA directly with your KMS provider. Your KMS credentials are not stored, and usage of created accounts require your KMS credentials to be sent with requests.\n */\nexport const createAccount = <ThrowOnError extends boolean = false>(\n\toptions?: Options<CreateAccountData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tCreateAccountResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/accounts\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Get Transactions\n * Search transactions with various filters and pagination\n */\nexport const getTransactions = <ThrowOnError extends boolean = false>(\n\toptions?: Options<GetTransactionsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).get<\n\t\tGetTransactionsResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions\",\n\t\t...options,\n\t});\n};\n\n/**\n * Transaction Analytics\n * Get transaction count analytics over time with filtering\n */\nexport const getTransactionAnalytics = <ThrowOnError extends boolean = false>(\n\toptions?: Options<GetTransactionAnalyticsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tGetTransactionAnalyticsResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/analytics\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Transaction Analytics Summary\n * Get a summary (total count and total gas calculation) for transactions within a time range, supporting complex nested filters.\n */\nexport const getTransactionAnalyticsSummary = <\n\tThrowOnError extends boolean = false,\n>(\n\toptions?: Options<GetTransactionAnalyticsSummaryData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tGetTransactionAnalyticsSummaryResponses,\n\t\tGetTransactionAnalyticsSummaryErrors,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/analytics-summary\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Search Transactions\n * Advanced search for transactions with complex nested filters\n */\nexport const searchTransactions = <ThrowOnError extends boolean = false>(\n\toptions?: Options<SearchTransactionsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tSearchTransactionsResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/search\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Get Activity Logs\n * Get paginated activity logs for a specific transaction with tenancy enforcement\n */\nexport const getActivityLogs = <ThrowOnError extends boolean = false>(\n\toptions: Options<GetActivityLogsData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).get<\n\t\tGetActivityLogsResponses,\n\t\tGetActivityLogsErrors,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/activity-logs\",\n\t\t...options,\n\t});\n};\n\n/**\n * Search Activity Logs\n * Search activity logs across transactions with advanced filtering and tenancy enforcement\n */\nexport const searchActivityLogs = <ThrowOnError extends boolean = false>(\n\toptions?: Options<SearchActivityLogsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tSearchActivityLogsResponses,\n\t\tSearchActivityLogsErrors,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/activity-logs/search\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n", "import type { Config } from \"./client/client/index.js\";\nimport { client } from \"./client/client.gen.js\";\n\nexport type EngineClientOptions = {\n\treadonly clientId?: string;\n\treadonly secretKey?: string;\n};\n\nexport function configure(\n\toptions: EngineClientOptions & { override?: Config },\n) {\n\tclient.setConfig({\n\t\tbodySerializer: stringify,\n\t\theaders: {\n\t\t\t...(options.clientId && { \"x-client-id\": options.clientId }),\n\t\t\t...(options.secretKey && { \"x-secret-key\": options.secretKey }),\n\t\t},\n\t\t...(options.override ?? {}),\n\t});\n}\n\nfunction stringify(\n\t// biome-ignore lint/suspicious/noExplicitAny: JSON.stringify signature\n\tvalue: any,\n\t// biome-ignore lint/suspicious/noExplicitAny: JSON.stringify signature\n\treplacer?: ((this: any, key: string, value: any) => any) | null,\n\tspace?: string | number,\n) {\n\tconst res = JSON.stringify(\n\t\tvalue,\n\t\t(key, value_) => {\n\t\t\tconst value__ = typeof value_ === \"bigint\" ? value_.toString() : value_;\n\t\t\treturn typeof replacer === \"function\" ? replacer(key, value__) : value__;\n\t\t},\n\t\tspace,\n\t);\n\treturn res;\n}\n\nexport type MaybeErrorResponse<D, E> = { result: D } | { error: E };\n\nexport function isErrorResponse<D, E>(\n\tres: MaybeErrorResponse<D, E>,\n): res is { error: E } {\n\treturn \"error\" in res;\n}\n\nexport function isSuccessResponse<D, E>(\n\tres: MaybeErrorResponse<D, E>,\n): res is { result: D } {\n\treturn \"result\" in res;\n}\n", "import { createAccount } from \"@thirdweb-dev/engine\";\nimport { stringify } from \"viem\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\n\nexport type CreateServerWalletArgs = {\n  client: ThirdwebClient;\n  label: string;\n};\n\n/**\n * Create a server wallet.\n * @param params - The parameters for the server wallet.\n * @param params.client - The thirdweb client to use.\n * @param params.label - The label for the server wallet.\n * @returns The server wallet signer address and the predicted smart account address.\n * @engine\n * @example\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const serverWallet = await Engine.createServerWallet({\n *   client,\n *   label: \"My Server Wallet\",\n * });\n * console.log(serverWallet.address);\n * console.log(serverWallet.smartAccountAddress);\n * ```\n */\nexport async function createServerWallet(params: CreateServerWalletArgs) {\n  const { client, label } = params;\n  const result = await createAccount({\n    baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n    body: {\n      label,\n    },\n    bodySerializer: stringify,\n    fetch: getClientFetch(client),\n  });\n\n  if (result.error) {\n    throw new Error(\n      `Error creating server wallet with label ${label}: ${stringify(\n        result.error,\n      )}`,\n    );\n  }\n\n  const data = result.data?.result;\n\n  if (!data) {\n    throw new Error(`No server wallet created with label ${label}`);\n  }\n\n  return data;\n}\n", "import { searchTransactions } from \"@thirdweb-dev/engine\";\nimport type { Chain } from \"../chains/types.js\";\nimport { getCachedChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\n\nexport type RevertData = {\n  errorName: string;\n  errorArgs: Record<string, unknown>;\n};\n\ntype ExecutionResult4337Serialized =\n  | {\n      status: \"QUEUED\";\n    }\n  | {\n      status: \"FAILED\";\n      error: string;\n    }\n  | {\n      status: \"SUBMITTED\";\n      monitoringStatus: \"WILL_MONITOR\" | \"CANNOT_MONITOR\";\n      userOpHash: string;\n    }\n  | ({\n      status: \"CONFIRMED\";\n      userOpHash: Hex;\n      transactionHash: Hex;\n      actualGasCost: string;\n      actualGasUsed: string;\n      nonce: string;\n    } & (\n      | {\n          onchainStatus: \"SUCCESS\";\n        }\n      | {\n          onchainStatus: \"REVERTED\";\n          revertData?: RevertData;\n        }\n    ));\n\nexport type ExecutionResult = Prettify<\n  ExecutionResult4337Serialized & {\n    chain: Chain;\n    from: string | undefined;\n    id: string;\n    createdAt: string;\n    confirmedAt: string | null;\n    cancelledAt: string | null;\n  }\n>;\n\n/**\n * Get the execution status of a transaction.\n * @param args - The arguments for the transaction.\n * @param args.client - The thirdweb client to use.\n * @param args.transactionId - The id of the transaction to get the status of.\n * @engine\n * @example\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const executionResult = await Engine.getTransactionStatus({\n *   client,\n *   transactionId,\n * });\n * console.log(executionResult.status);\n * ```\n */\nexport async function getTransactionStatus(args: {\n  client: ThirdwebClient;\n  transactionId: string;\n}): Promise<ExecutionResult> {\n  const { client, transactionId } = args;\n  const searchResult = await searchTransactions({\n    baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n    body: {\n      filters: [\n        {\n          field: \"id\",\n          operation: \"OR\",\n          values: [transactionId],\n        },\n      ],\n    },\n    bodySerializer: stringify,\n    fetch: getClientFetch(client),\n  });\n\n  if (searchResult.error) {\n    throw new Error(\n      `Error searching for transaction ${transactionId}: ${stringify(\n        searchResult.error,\n      )}`,\n    );\n  }\n\n  const data = searchResult.data?.result?.transactions?.[0];\n\n  if (!data) {\n    throw new Error(`Transaction ${transactionId} not found`);\n  }\n\n  const executionResult = data.executionResult as ExecutionResult4337Serialized;\n  return {\n    ...executionResult,\n    cancelledAt: data.cancelledAt,\n    chain: getCachedChain(Number(data.chainId)),\n    confirmedAt: data.confirmedAt,\n    createdAt: data.createdAt,\n    from: data.from ?? undefined,\n    id: data.id,\n  };\n}\n", "import { listAccounts } from \"@thirdweb-dev/engine\";\nimport { stringify } from \"viem\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\n\nexport type GetServerWalletsArgs = {\n  client: ThirdwebClient;\n};\n\n/**\n * List all server wallets.\n * @param params - The parameters for the server wallet.\n * @param params.client - The thirdweb client to use.\n * @returns an array of server wallets with their signer address and predicted smart account address.\n * @engine\n * @example\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const serverWallets = await Engine.getServerWallets({\n *   client,\n * });\n * console.log(serverWallets);\n * ```\n */\nexport async function getServerWallets(params: GetServerWalletsArgs) {\n  const { client } = params;\n  const result = await listAccounts({\n    baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n    bodySerializer: stringify,\n    fetch: getClientFetch(client),\n  });\n\n  if (result.error) {\n    throw new Error(`Error listing server wallets: ${stringify(result.error)}`);\n  }\n\n  const data = result.data?.result;\n\n  if (!data) {\n    throw new Error(\"No server wallets found\");\n  }\n\n  return data;\n}\n", "import {\n  searchTransactions as engineSearchTransactions,\n  type TransactionsFilterNested,\n  type TransactionsFilterValue,\n} from \"@thirdweb-dev/engine\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\n\nexport type SearchTransactionsArgs = {\n  client: ThirdwebClient;\n  filters?: (TransactionsFilterValue | TransactionsFilterNested)[];\n  pageSize?: number;\n  page?: number;\n};\n\n/**\n * Search for transactions by their ids.\n * @param args - The arguments for the search.\n * @param args.client - The thirdweb client to use.\n * @param args.transactionIds - The ids of the transactions to search for.\n * @engine\n * @example\n * ## Search for transactions by their ids\n *\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const transactions = await Engine.searchTransactions({\n *   client,\n *   filters: [\n *     {\n *       field: \"id\",\n *       values: [\"1\", \"2\", \"3\"],\n *     },\n *   ],\n * });\n * console.log(transactions);\n * ```\n *\n * ## Search for transactions by chain id\n *\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const transactions = await Engine.searchTransactions({\n *   client,\n *   filters: [\n *     {\n *       field: \"chainId\",\n *       values: [\"1\", \"137\"],\n *     },\n *   ],\n * });\n * console.log(transactions);\n * ```\n *\n * ## Search for transactions by sender wallet address\n *\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const transactions = await Engine.searchTransactions({\n *   client,\n *   filters: [\n *     {\n *       field: \"from\",\n *       values: [\"0x1234567890123456789012345678901234567890\"],\n *     },\n *   ],\n * });\n * console.log(transactions);\n * ```\n *\n * ## Combined search\n *\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const transactions = await Engine.searchTransactions({\n *   client,\n *   filters: [\n *     {\n *       filters: [\n *         {\n *          field: \"from\",\n *          values: [\"0x1234567890123456789012345678901234567890\"],\n *        },\n *        {\n *          field: \"chainId\",\n *          values: [\"8453\"],\n *        },\n *      ],\n *      operation: \"AND\",\n *    },\n *  ],\n *  pageSize: 100,\n *  page: 0,\n * });\n * console.log(transactions);\n * ```\n */\nexport async function searchTransactions(args: SearchTransactionsArgs) {\n  const { client, filters, pageSize = 100, page = 1 } = args;\n  const searchResult = await engineSearchTransactions({\n    baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n    body: {\n      filters,\n      limit: pageSize,\n      page,\n    },\n    bodySerializer: stringify,\n    fetch: getClientFetch(client),\n  });\n\n  if (searchResult.error) {\n    throw new Error(\n      `Error searching for transaction with filters ${stringify(filters)}: ${stringify(\n        searchResult.error,\n      )}`,\n    );\n  }\n\n  const data = searchResult.data?.result;\n\n  if (!data) {\n    throw new Error(`No transactions found with filters ${stringify(filters)}`);\n  }\n\n  return data;\n}\n", "import { stringify } from \"viem\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { WaitForReceiptOptions } from \"../transaction/actions/wait-for-tx-receipt.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { getTransactionStatus } from \"./get-status.js\";\n\n/**\n * Wait for a transaction to be submitted onchain and return the transaction hash.\n * @param args - The arguments for the transaction.\n * @param args.client - The thirdweb client to use.\n * @param args.transactionId - The id of the transaction to wait for.\n * @param args.timeoutInSeconds - The timeout in seconds.\n * @engine\n * @example\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const { transactionHash } = await Engine.waitForTransactionHash({\n *   client,\n *   transactionId, // the transaction id returned from enqueueTransaction\n * });\n * ```\n */\nexport async function waitForTransactionHash(args: {\n  client: ThirdwebClient;\n  transactionId: string;\n  timeoutInSeconds?: number;\n}): Promise<WaitForReceiptOptions> {\n  const startTime = Date.now();\n  const TIMEOUT_IN_MS = args.timeoutInSeconds\n    ? args.timeoutInSeconds * 1000\n    : 5 * 60 * 1000; // 5 minutes in milliseconds\n\n  while (Date.now() - startTime < TIMEOUT_IN_MS) {\n    const executionResult = await getTransactionStatus(args);\n    const status = executionResult.status;\n\n    switch (status) {\n      case \"FAILED\": {\n        throw new Error(\n          `Transaction failed: ${stringify(executionResult.error) || \"Unknown error\"}`,\n        );\n      }\n      case \"CONFIRMED\": {\n        const onchainStatus =\n          executionResult && \"onchainStatus\" in executionResult\n            ? executionResult.onchainStatus\n            : null;\n        if (onchainStatus === \"REVERTED\") {\n          const revertData =\n            \"revertData\" in executionResult\n              ? executionResult.revertData\n              : undefined;\n          throw new Error(\n            `Transaction reverted: ${revertData?.errorName || \"unknown error\"} ${revertData?.errorArgs ? stringify(revertData.errorArgs) : \"\"} - ${executionResult.transactionHash ? executionResult.transactionHash : \"\"}`,\n          );\n        }\n        return {\n          chain: executionResult.chain,\n          client: args.client,\n          transactionHash: executionResult.transactionHash as Hex,\n        };\n      }\n      default: {\n        // wait for the transaction to be confirmed\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n      }\n    }\n  }\n  throw new Error(\n    `Transaction timed out after ${TIMEOUT_IN_MS / 1000} seconds`,\n  );\n}\n", "import {\n  isSuccessResponse,\n  type SendTransactionData,\n  type SignMessageData,\n  type SpecificExecutionOptions,\n  sendTransaction,\n  signMessage,\n  signTypedData,\n} from \"@thirdweb-dev/engine\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { encode } from \"../transaction/actions/encode.js\";\nimport { toSerializableTransaction } from \"../transaction/actions/to-serializable-transaction.js\";\nimport type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { type Hex, toHex } from \"../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../wallets/interfaces/wallet.js\";\nimport { waitForTransactionHash } from \"./wait-for-tx-hash.js\";\n\ntype ExecutionOptions = Prettify<SpecificExecutionOptions>;\n\n/**\n * Options for creating an server wallet.\n */\nexport type ServerWalletOptions = {\n  /**\n   * The thirdweb client to use for authentication to thirdweb services.\n   */\n  client: ThirdwebClient;\n  /**\n   * Optional vault access token to use your server wallet.\n   * If not provided, the server wallet will use the project secret key to authenticate.\n   */\n  vaultAccessToken?: string;\n  /**\n   * The server wallet address to use for sending transactions inside engine.\n   */\n  address: string;\n  /**\n   * The chain to use for signing messages and typed data (smart server wallet only).\n   */\n  chain?: Chain;\n  /**\n   * Optional custom execution options to use for sending transactions and signing data.\n   */\n  executionOptions?: ExecutionOptions;\n};\n\nexport type ServerWallet = Account & {\n  enqueueTransaction: (args: {\n    transaction: PreparedTransaction;\n    simulate?: boolean;\n  }) => Promise<{ transactionId: string }>;\n  enqueueBatchTransaction: (args: {\n    transactions: PreparedTransaction[];\n  }) => Promise<{ transactionId: string }>;\n};\n\n/**\n * Create a server wallet for sending transactions and signing messages via engine (v3+).\n * @param options - The server wallet options.\n * @returns An account object that can be used to send transactions and sign messages.\n * @engine\n * @example\n * ### Creating a server wallet\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const client = createThirdwebClient({\n *   secretKey: \"<your-project-secret-key>\",\n * });\n *\n * const myServerWallet = Engine.serverWallet({\n *   client,\n *   address: \"<your-server-wallet-address>\",\n *   vaultAccessToken: \"<your-vault-access-token>\",\n * });\n * ```\n *\n * ### Sending a transaction\n * ```ts\n * // prepare the transaction\n * const transaction = claimTo({\n *   contract,\n *   to: \"0x...\",\n *   quantity: 1n,\n * });\n *\n * // enqueue the transaction\n * const { transactionId } = await myServerWallet.enqueueTransaction({\n *   transaction,\n * });\n * ```\n *\n * ### Polling for the transaction to be submitted onchain\n * ```ts\n * // optionally poll for the transaction to be submitted onchain\n * const { transactionHash } = await Engine.waitForTransactionHash({\n *   client,\n *   transactionId,\n * });\n * console.log(\"Transaction sent:\", transactionHash);\n * ```\n *\n *  ### Sending a batch of transactions\n * ```ts\n * // prepare the transactions\n * const transaction1 = claimTo({\n *   contract,\n *   to: firstRecipient,\n *   quantity: 1n,\n * });\n * const transaction2 = claimTo({\n *   contract,\n *   to: secondRecipient,\n *   quantity: 1n,\n * });\n *\n *\n * // enqueue the transactions in a batch\n * const { transactionId } = await myServerWallet.enqueueBatchTransaction({\n *   transactions: [transaction1, transaction2],\n * });\n * ```\n *\n * ### Polling for the batch of transactions to be submitted onchain\n * ```ts\n * // optionally poll for the transaction to be submitted onchain\n * const { transactionHash } = await Engine.waitForTransactionHash({\n *   client,\n *   transactionId,\n * });\n * console.log(\"Transaction sent:\", transactionHash);\n * ```\n *\n * ### Getting the execution status of a transaction\n * ```ts\n * const executionResult = await Engine.getTransactionStatus({\n *   client,\n *   transactionId,\n * });\n * console.log(\"Transaction status:\", executionResult.status);\n * ```\n */\nexport function serverWallet(options: ServerWalletOptions): ServerWallet {\n  const { client, vaultAccessToken, address, chain, executionOptions } =\n    options;\n\n  const headers: HeadersInit = vaultAccessToken\n    ? {\n        \"x-vault-access-token\": vaultAccessToken,\n      }\n    : {};\n\n  const getExecutionOptionsWithChainId = (\n    chainId: number,\n  ): SendTransactionData[\"body\"][\"executionOptions\"] => {\n    if (!executionOptions) {\n      return {\n        chainId,\n        from: address,\n        type: \"auto\",\n      };\n    }\n    switch (executionOptions.type) {\n      case \"auto\":\n        return {\n          chainId,\n          from: address,\n          type: \"auto\",\n        };\n      case \"ERC4337\":\n        return {\n          ...executionOptions,\n          chainId,\n          type: \"ERC4337\",\n        };\n    }\n  };\n\n  const getSigningOptions = (\n    chainId: number | undefined,\n  ): SignMessageData[\"body\"][\"signingOptions\"] => {\n    // if no chainId passed specifically for this signature\n    // we HAVE TO fallback to EOA signature\n    if (!chainId) {\n      return {\n        from: address,\n        type: \"eoa\",\n      };\n    }\n\n    if (!executionOptions) {\n      return {\n        chainId,\n        from: address,\n        type: \"auto\",\n      };\n    }\n\n    switch (executionOptions.type) {\n      case \"ERC4337\": {\n        return {\n          chainId,\n          ...executionOptions,\n          type: \"ERC4337\",\n        };\n      }\n\n      case \"auto\": {\n        return {\n          chainId,\n          from: address,\n          type: \"auto\",\n        };\n      }\n    }\n  };\n\n  const enqueueTx = async (transaction: SendTransactionOption[]) => {\n    if (transaction.length === 0) {\n      throw new Error(\"No transactions to enqueue\");\n    }\n    const firstTransaction = transaction[0];\n    if (!firstTransaction) {\n      throw new Error(\"No transactions to enqueue\");\n    }\n    const chainId = firstTransaction.chainId;\n    // Validate all transactions are on the same chain\n    for (let i = 1; i < transaction.length; i++) {\n      if (transaction[i]?.chainId !== chainId) {\n        throw new Error(\n          `All transactions in batch must be on the same chain. Expected ${chainId}, got ${transaction[i]?.chainId} at index ${i}`,\n        );\n      }\n    }\n    const body = {\n      executionOptions: getExecutionOptionsWithChainId(chainId),\n      params: transaction.map((t) => ({\n        data: t.data,\n        to: t.to,\n        value: t.value?.toString(),\n      })),\n    };\n\n    const result = await sendTransaction({\n      baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n      body,\n      bodySerializer: stringify,\n      fetch: getClientFetch(client),\n      headers,\n    });\n\n    if (result.error) {\n      throw new Error(`Error sending transaction: ${stringify(result.error)}`);\n    }\n\n    const data = result.data?.result;\n    if (!data) {\n      throw new Error(\"No data returned from engine\");\n    }\n    return data.transactions.map((t) => t.id);\n  };\n\n  const getAddress = () => {\n    if (\n      executionOptions?.type === \"ERC4337\" &&\n      executionOptions.smartAccountAddress\n    ) {\n      return executionOptions.smartAccountAddress;\n    }\n    return address;\n  };\n\n  return {\n    address: getAddress(),\n    enqueueBatchTransaction: async (args: {\n      transactions: PreparedTransaction[];\n    }) => {\n      const serializedTransactions: SendTransactionOption[] = [];\n      for (const transaction of args.transactions) {\n        const [to, data, value] = await Promise.all([\n          transaction.to ? resolvePromisedValue(transaction.to) : null,\n          encode(transaction),\n          transaction.value ? resolvePromisedValue(transaction.value) : null,\n        ]);\n        serializedTransactions.push({\n          chainId: transaction.chain.id,\n          data,\n          to: to ?? undefined,\n          value: value ?? undefined,\n        });\n      }\n      const transactionIds = await enqueueTx(serializedTransactions);\n      const transactionId = transactionIds[0];\n      if (!transactionId) {\n        throw new Error(\"No transactionId returned from engine\");\n      }\n      return { transactionId };\n    },\n    enqueueTransaction: async (args: {\n      transaction: PreparedTransaction;\n      simulate?: boolean;\n    }) => {\n      let serializedTransaction: SendTransactionOption;\n      if (args.simulate) {\n        serializedTransaction = await toSerializableTransaction({\n          transaction: args.transaction,\n        });\n      } else {\n        const [to, data, value] = await Promise.all([\n          args.transaction.to\n            ? resolvePromisedValue(args.transaction.to)\n            : null,\n          encode(args.transaction),\n          args.transaction.value\n            ? resolvePromisedValue(args.transaction.value)\n            : null,\n        ]);\n        serializedTransaction = {\n          chainId: args.transaction.chain.id,\n          data,\n          to: to ?? undefined,\n          value: value ?? undefined,\n        };\n      }\n      const transactionIds = await enqueueTx([serializedTransaction]);\n      const transactionId = transactionIds[0];\n      if (!transactionId) {\n        throw new Error(\"No transactionId returned from engine\");\n      }\n      return { transactionId };\n    },\n    sendBatchTransaction: async (transactions: SendTransactionOption[]) => {\n      const transactionIds = await enqueueTx(transactions);\n      const transactionId = transactionIds[0];\n      if (!transactionId) {\n        throw new Error(\"No transactionId returned from engine\");\n      }\n      return waitForTransactionHash({\n        client,\n        transactionId,\n      });\n    },\n    sendTransaction: async (transaction: SendTransactionOption) => {\n      const transactionIds = await enqueueTx([transaction]);\n      const transactionId = transactionIds[0];\n      if (!transactionId) {\n        throw new Error(\"No transactionId returned from engine\");\n      }\n      return waitForTransactionHash({\n        client,\n        transactionId,\n      });\n    },\n    signMessage: async (data) => {\n      const { message, chainId } = data;\n      let engineMessage: string | Hex;\n      let isBytes = false;\n      if (typeof message === \"string\") {\n        engineMessage = message;\n      } else {\n        engineMessage = toHex(message.raw);\n        isBytes = true;\n      }\n\n      const signingChainId = chainId || chain?.id;\n      if (!signingChainId) {\n        throw new Error(\"Chain ID is required for signing messages\");\n      }\n      const signResult = await signMessage({\n        baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n        body: {\n          params: [\n            {\n              format: isBytes ? \"hex\" : \"text\",\n              message: engineMessage,\n            },\n          ],\n          signingOptions: getSigningOptions(signingChainId),\n        },\n        bodySerializer: stringify,\n        fetch: getClientFetch(client),\n        headers,\n      });\n\n      if (signResult.error) {\n        throw new Error(\n          `Error signing message: ${stringify(signResult.error)}`,\n        );\n      }\n\n      const signatureResult = signResult.data?.result[0];\n      if (signatureResult && isSuccessResponse(signatureResult)) {\n        return signatureResult.result.signature as Hex;\n      }\n\n      throw new Error(\n        `Failed to sign message: ${stringify(signatureResult?.error) || \"Unknown error\"}`,\n      );\n    },\n    signTypedData: async (typedData) => {\n      const signingChainId = chain?.id;\n      if (!signingChainId) {\n        throw new Error(\"Chain ID is required for signing messages\");\n      }\n\n      const signResult = await signTypedData({\n        baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n        body: {\n          // biome-ignore lint/suspicious/noExplicitAny: TODO: fix ts / hey-api type clash\n          params: [typedData as any],\n          signingOptions: getSigningOptions(signingChainId),\n        },\n        bodySerializer: stringify,\n        fetch: getClientFetch(client),\n        headers,\n      });\n\n      if (signResult.error) {\n        throw new Error(\n          `Error signing message: ${stringify(signResult.error)}`,\n        );\n      }\n\n      const signatureResult = signResult.data?.result[0];\n      if (signatureResult && isSuccessResponse(signatureResult)) {\n        return signatureResult.result.signature as Hex;\n      }\n\n      throw new Error(\n        `Failed to sign message: ${stringify(signatureResult?.error) || \"Unknown error\"}`,\n      );\n    },\n  };\n}\n", "import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  formatBlock,\n  type GetBlockReturnType,\n  type Hash,\n} from \"viem\";\n\ntype GetBlockByHashParams<TIncludeTransactions extends boolean = false> = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: TIncludeTransactions;\n} & {\n  /** Hash of the block. */\n  blockHash: Hash;\n};\n\n/**\n * Retrieves a block by its hash.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the block retrieval.\n * @returns A promise that resolves to the retrieved block.\n * @throws An error if the block is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getBlockByHash } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const block = await eth_getBlockByHash(rpcRequest, {\n * blockHash: \"0x...\",\n * includeTransactions: true,\n * });\n * ```\n */\nexport async function eth_getBlockByHash<\n  TIncludeTransactions extends boolean = false,\n>(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetBlockByHashParams<TIncludeTransactions>,\n): Promise<GetBlockReturnType<undefined, TIncludeTransactions>> {\n  const includeTransactions = params.includeTransactions ?? false;\n\n  const block = await request({\n    method: \"eth_getBlockByHash\",\n    params: [params.blockHash, includeTransactions],\n  });\n  if (!block) {\n    throw new Error(\"Block not found\");\n  }\n  return formatBlock(block) as GetBlockReturnType<\n    undefined,\n    TIncludeTransactions\n  >;\n}\n", "import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  formatTransaction,\n  type Hash,\n  type Transaction,\n} from \"viem\";\n\ntype GetTransactionByHashParameters = {\n  hash: Hash;\n};\n\n/**\n * Retrieves a transaction by its hash.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the transaction.\n * @returns A promise that resolves to the transaction.\n * @throws An error if the transaction is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getTransactionByHash } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n *  const transaction = await eth_getTransactionByHash(rpcRequest, {\n *  hash: \"0x...\",\n * });\n * ```\n */\nexport async function eth_getTransactionByHash(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetTransactionByHashParameters,\n): Promise<Transaction> {\n  const receipt = await request({\n    method: \"eth_getTransactionByHash\",\n    params: [params.hash],\n  });\n\n  if (!receipt) {\n    throw new Error(\"Transaction not found.\");\n  }\n\n  return formatTransaction(receipt);\n}\n", "import { Value } from \"ox\";\nimport * as ox__AbiFunction from \"ox/AbiFunction\";\nimport { Transfer } from \"../../bridge/index.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../constants/addresses.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { decimals } from \"../../extensions/erc20/read/decimals.js\";\nimport type { PrepareTransactionOptions } from \"../../transaction/prepare-transaction.js\";\nimport type { PurchaseData } from \"../types.js\";\nimport type { QuoteApprovalInfo, QuotePaymentToken } from \"./commonTypes.js\";\n\n/**\n * The parameters for [`getBuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithCryptoTransfer) function\n * It facilitates a token transfer.\n * @buyCrypto\n */\nexport type GetBuyWithCryptoTransferParams = {\n  /**\n   * A client is the entry point to the thirdweb SDK. It is required for all other actions.\n   *\n   * You can create a client using the `createThirdwebClient` function.\n   * Refer to the [Creating a Client](https://portal.thirdweb.com/typescript/v5/client) documentation for more information.\n   *\n   */\n  client: ThirdwebClient;\n\n  /**\n   * The address of wallet that pays for the tokens.\n   */\n  fromAddress: string;\n\n  /**\n   * The address of the wallet where the tokens are sent\n   */\n  toAddress: string;\n\n  /**\n   * The chain id of the transfer token.\n   */\n  chainId: number;\n\n  /**\n   * The token address of the transfer token.\n   */\n  tokenAddress: string;\n\n  /**\n   * The amount of token to be transferred.\n   */\n  amount: string;\n\n  /**\n   * Extra details to store with the purchase.\n   *\n   * This details will be stored with the purchase and can be retrieved later via the status API or Webhook\n   */\n  purchaseData?: PurchaseData;\n\n  /**\n   * For direct transfers, specify who will pay for the transfer fee. Can be \"sender\" or \"receiver\".\n   */\n  feePayer?: \"sender\" | \"receiver\";\n\n  /**\n   * @hidden\n   */\n  paymentLinkId?: string;\n};\n\n/**\n * @buyCrypto\n */\nexport type BuyWithCryptoTransfer = {\n  transactionRequest: PrepareTransactionOptions;\n  approvalData?: QuoteApprovalInfo;\n  fromAddress: string;\n  toAddress: string;\n  paymentToken: QuotePaymentToken;\n  processingFee: QuotePaymentToken;\n  estimatedGasCostUSDCents: number;\n  client: ThirdwebClient;\n};\n\n/**\n * Get a quote of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) to facilitate a token transfer transaction.\n * Using this instead of a native transfer allows you to receive status and webhooks about successful or failed payments.\n *\n * Once you have the quote, you can use `prepareTransaction` and prepare the transaction for submission.\n * @param params - object of type [`GetBuyWithCryptoTransferParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithCryptoTransferParams)\n * @returns Object of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) which contains the information about the transfer\n * @example\n *\n * ```ts\n * import { getBuyWithCryptoTransfer } from \"thirdweb/pay\";\n *\n * const transfer = await getBuyWithCryptoTransfer({\n *  client,\n *  fromAddress: \"0x...\", // wallet address\n *  toAddress: \"0x...\", // recipient address - likely to be your wallet\n *  chainId: 10, // chain id of the token\n *  tokenAddress: \"0x...\", // address of the token\n *  amount: \"10\", // amount of token to transfer\n *  purchaseData: {  // any metadata for you to attribute this purchase\n *    \"customerId\": \"yourId\"\n *  }\n * });\n * ```\n * @deprecated\n * @buyCrypto\n */\nexport async function getBuyWithCryptoTransfer(\n  params: GetBuyWithCryptoTransferParams,\n): Promise<BuyWithCryptoTransfer> {\n  try {\n    const tokenContract = getContract({\n      address: params.tokenAddress,\n      chain: getCachedChain(params.chainId),\n      client: params.client,\n    });\n    const tokenDecimals =\n      tokenContract.address.toLowerCase() === NATIVE_TOKEN_ADDRESS\n        ? 18\n        : await decimals({\n            contract: tokenContract,\n          });\n    const amount = Value.from(params.amount, tokenDecimals);\n    const quote = await Transfer.prepare({\n      amount,\n      chainId: params.chainId,\n      client: params.client,\n      feePayer: params.feePayer,\n      paymentLinkId: params.paymentLinkId,\n      purchaseData: params.purchaseData,\n      receiver: params.toAddress,\n      sender: params.fromAddress,\n      tokenAddress: params.tokenAddress,\n    });\n\n    const firstStep = quote.steps[0];\n    if (!firstStep) {\n      throw new Error(\n        \"This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.\",\n      );\n    }\n\n    const approvalTxs = firstStep.transactions.filter(\n      (tx) => tx.action === \"approval\",\n    );\n    if (approvalTxs.length > 1) {\n      throw new Error(\n        \"This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.\",\n      );\n    }\n    const approvalTx = approvalTxs[0];\n\n    let approvalData: QuoteApprovalInfo | undefined;\n    if (approvalTx) {\n      const abiFunction = ox__AbiFunction.from([\n        \"function approve(address spender, uint256 amount)\",\n      ]);\n      const [spender, amount] = ox__AbiFunction.decodeData(\n        abiFunction,\n        approvalTx.data,\n      );\n      approvalData = {\n        amountWei: amount.toString(),\n        chainId: firstStep.originToken.chainId,\n        spenderAddress: spender,\n        tokenAddress: firstStep.originToken.address,\n      };\n    }\n\n    const txs = firstStep.transactions.filter((tx) => tx.action !== \"approval\");\n    if (txs.length > 1) {\n      throw new Error(\n        \"This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.\",\n      );\n    }\n    const tx = txs[0];\n    if (!tx) {\n      throw new Error(\n        \"This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.\",\n      );\n    }\n\n    const transfer: BuyWithCryptoTransfer = {\n      approvalData,\n      client: params.client,\n      estimatedGasCostUSDCents: 0,\n      fromAddress: params.fromAddress,\n      paymentToken: {\n        amount: Value.format(\n          quote.originAmount,\n          firstStep.originToken.decimals,\n        ).toString(),\n        amountUSDCents:\n          Number(\n            Value.format(quote.originAmount, firstStep.originToken.decimals),\n          ) *\n          (firstStep.originToken.prices[\"USD\"] || 0) *\n          100,\n        amountWei: quote.originAmount.toString(),\n        token: {\n          chainId: firstStep.originToken.chainId,\n          decimals: firstStep.originToken.decimals,\n          name: firstStep.originToken.name,\n          priceUSDCents: (firstStep.originToken.prices[\"USD\"] || 0) * 100,\n          symbol: firstStep.originToken.symbol,\n          tokenAddress: firstStep.originToken.address,\n        },\n      },\n      processingFee: {\n        amount:\n          params.feePayer === \"sender\"\n            ? Value.format(\n                quote.originAmount - quote.destinationAmount,\n                firstStep.originToken.decimals,\n              ).toString()\n            : \"0\",\n        amountUSDCents:\n          params.feePayer === \"sender\"\n            ? Number(\n                Value.format(\n                  quote.originAmount - quote.destinationAmount,\n                  firstStep.originToken.decimals,\n                ),\n              ) *\n              (firstStep.originToken.prices[\"USD\"] || 0) *\n              100\n            : 0,\n        amountWei:\n          params.feePayer === \"sender\"\n            ? (quote.originAmount - quote.destinationAmount).toString()\n            : \"0\",\n        token: {\n          chainId: firstStep.originToken.chainId,\n          decimals: firstStep.originToken.decimals,\n          name: firstStep.originToken.name,\n          priceUSDCents: (firstStep.originToken.prices[\"USD\"] || 0) * 100,\n          symbol: firstStep.originToken.symbol,\n          tokenAddress: firstStep.originToken.address,\n        },\n      },\n      toAddress: params.toAddress,\n      transactionRequest: {\n        ...tx,\n        extraGas: 50000n, // extra gas buffer\n      },\n    };\n\n    return transfer;\n  } catch (error) {\n    console.error(\"Error getting buy with crypto transfer\", error);\n    throw error;\n  }\n}\n", "import type { Abi, AbiFunction } from \"abitype\";\nimport { parseAbiItem } from \"abitype\";\nimport { resolveContractAbi } from \"../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\n\n/**\n * Resolves and returns the ABI function with the specified method name.\n * Throws an error if the function is not found in the ABI.\n * @template abiFn - The type of the ABI function.\n * @param method - The name of the method to resolve.\n * @returns The resolved ABI function.\n * @throws Error if the function is not found in the ABI.\n * @example\n * ```ts\n * import { resolveMethod, prepareContractCall } from \"thirdweb\";\n * const tx = prepareContractCall({\n *  contract,\n *  // automatically resolves the necessary abi to encode the transaction\n *  method: resolveMethod(\"transfer\"),\n *  // however there is no type completion for params in this case (as the resolution is async and happens at runtime)\n *  params: [to, value],\n * });\n * ```\n * @contract\n */\nexport function resolveMethod<\n  abiFn extends AbiFunction,\n  TAbi extends Abi = Abi,\n>(method: string) {\n  return async (contract: ThirdwebContract<TAbi>) => {\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // we know it will be an abi function so we can cast it\n      return parseAbiItem(method) as AbiFunction;\n    }\n\n    const resolvedAbi = contract.abi?.length\n      ? contract.abi\n      : await resolveContractAbi<Abi>(contract);\n    // we try to find the abiFunction in the abi\n    const abiFunction = resolvedAbi.find((item) => {\n      // if the item is not a function we can ignore it\n      if (item.type !== \"function\") {\n        return false;\n      }\n      // if the item is a function we can compare the name\n      return item.name === method;\n    }) as abiFn | undefined;\n\n    if (!abiFunction) {\n      throw new Error(`could not find function with name \"${method}\" in abi`);\n    }\n    return abiFunction;\n  };\n}\n", "import type * as ox__Signature from \"ox/Signature\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { HashTypedDataParams } from \"../utils/hashing/hashTypedData.js\";\nimport { type VerifyHashParams, verifyHash } from \"./verify-hash.js\";\n\nexport type VerifyTypedDataParams<\n  typedData extends\n    | ox__TypedData.TypedData\n    | Record<string, unknown> = ox__TypedData.TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = Omit<VerifyHashParams, \"hash\"> &\n  ox__TypedData.Definition<typedData, primaryType> & {\n    address: string;\n    signature: string | Uint8Array | ox__Signature.Signature;\n    client: ThirdwebClient;\n    chain: Chain;\n    accountFactory?: {\n      address: string;\n      verificationCalldata: Hex;\n    };\n  };\n\n/**\n * Verify am [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data signature. This function is interoperable with all wallet types (smart accounts or EOAs).\n *\n * @param {string} options.address The address that signed the typed data\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n * @param {typeof VerifyTypedDataParams.message} options.message The EIP-712 message that was signed.\n * @param {typeof VerifyTypedDataParams.domain} options.domain The EIP-712 domain that was signed.\n * @param {typeof VerifyTypedDataParams.primaryType} options.primaryType The EIP-712 primary type that was signed.\n * @param {typeof VerifyTypedDataParams.types} options.types The EIP-712 types that were signed.\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyTypedData } from \"thirdweb/utils\";\n * const isValid = await verifyTypedData({\n *   address: \"0x...\",\n *   signature: \"0x...\",\n *   client,\n *   chain,\n *   domain: {\n      name: \"Ether Mail\",\n      version: \"1\",\n      chainId: 1,\n      verifyingContract: \"0x0000000000000000000000000000000000000000\",\n    },\n *   primaryType: \"Mail\",\n *   types: {\n      Person: [\n        { name: \"name\", type: \"string\" },\n        { name: \"wallet\", type: \"address\" },\n      ],\n      Mail: [\n        { name: \"from\", type: \"Person\" },\n        { name: \"to\", type: \"Person\" },\n        { name: \"contents\", type: \"string\" },\n      ],\n    },\n    message: {\n      from: {\n        name: \"Cow\",\n        wallet: \"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\",\n      },\n      to: {\n        name: \"Bob\",\n        wallet: \"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\",\n      },\n      contents: \"Hello, Bob!\",\n    },\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyTypedData<\n  typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>({\n  address,\n  signature,\n  client,\n  chain,\n  accountFactory,\n  message,\n  domain,\n  primaryType,\n  types,\n}: VerifyTypedDataParams<typedData, primaryType>): Promise<boolean> {\n  const messageHash = ox__TypedData.getSignPayload({\n    domain,\n    message,\n    primaryType,\n    types,\n  } as HashTypedDataParams);\n  return verifyHash({\n    accountFactory,\n    address,\n    chain,\n    client,\n    hash: messageHash,\n    signature,\n  });\n}\n", "import type * as ox__Authorization from \"ox/Authorization\";\nimport type { Address } from \"../../../utils/address.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\n\n/**\n * An EIP-7702 authorization object fully prepared and ready for signing.\n *\n * @beta\n * @transaction\n */\nexport type AuthorizationRequest = {\n  address: Address;\n  chainId: number;\n  nonce: bigint;\n};\n\n/**\n * Represents a signed EIP-7702 authorization object.\n *\n * @beta\n * @transaction\n */\nexport type SignedAuthorization = ox__Authorization.ListSigned[number];\n\n/**\n * Sign the given EIP-7702 authorization object.\n * @param options - The options for `signAuthorization`\n * Refer to the type [`SignAuthorizationOptions`](https://portal.thirdweb.com/references/typescript/v5/SignAuthorizationOptions)\n * @returns The signed authorization object\n *\n * ```ts\n * import { signAuthorization } from \"thirdweb\";\n *\n * const authorization = await signAuthorization({\n *     request: {\n *         address: \"0x...\",\n *         chainId: 911867,\n *         nonce: 100n,\n *     },\n *     account: myAccount,\n * });\n * ```\n *\n * @beta\n * @transaction\n */\nexport async function signAuthorization(options: {\n  account: Account;\n  request: AuthorizationRequest;\n}): Promise<SignedAuthorization> {\n  const { account, request } = options;\n  if (typeof account.signAuthorization === \"undefined\") {\n    throw new Error(\n      \"This account type does not yet support signing EIP-7702 authorizations\",\n    );\n  }\n  return account.signAuthorization(request);\n}\n"],
  "mappings": "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",
  "names": ["sha256", "sha256", "searchTransactions", "joinedValues", "config", "request", "sendTransaction", "client", "client", "stringify", "client", "searchTransactions", "client", "stringify", "client", "_a", "sendTransaction", "stringify", "getAddress", "tx", "amount", "client"]
}
