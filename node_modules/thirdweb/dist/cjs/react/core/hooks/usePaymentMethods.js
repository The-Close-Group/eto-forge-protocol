"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePaymentMethods = usePaymentMethods;
const react_query_1 = require("@tanstack/react-query");
const Chains_js_1 = require("../../../bridge/Chains.js");
const Routes_js_1 = require("../../../bridge/Routes.js");
const utils_js_1 = require("../../../chains/utils.js");
const get_tokens_js_1 = require("../../../insight/get-tokens.js");
const units_js_1 = require("../../../utils/units.js");
const useActiveWallet_js_1 = require("./wallets/useActiveWallet.js");
/**
 * Hook that returns available payment methods for BridgeEmbed
 * Fetches real routes data based on the destination token
 *
 * @param options - Configuration options
 * @param options.destinationToken - The destination token to find routes for
 * @param options.client - ThirdwebClient for API calls
 * @returns Available payment methods with route data
 *
 * @example
 * ```tsx
 * const { data: paymentMethods, isLoading, error } = usePaymentMethods({
 *   destinationToken,
 *   client
 * });
 * ```
 */
function usePaymentMethods(options) {
    const { destinationToken, destinationAmount, client, payerWallet, includeDestinationToken, } = options;
    const localWallet = (0, useActiveWallet_js_1.useActiveWallet)(); // TODO (bridge): get all connected wallets
    const wallet = payerWallet || localWallet;
    const routesQuery = (0, react_query_1.useQuery)({
        enabled: !!wallet,
        queryFn: async () => {
            if (!wallet) {
                throw new Error("No wallet connected");
            }
            // 1. Get all supported chains
            const [allChains, insightEnabledChainIds] = await Promise.all([
                (0, Chains_js_1.chains)({ client }),
                (0, utils_js_1.getInsightEnabledChainIds)(),
            ]);
            // 2. Check insight availability for all chains
            const insightEnabledChains = allChains.filter((c) => insightEnabledChainIds.includes(c.chainId));
            // 3. Get all owned tokens for insight-enabled chains
            let allOwnedTokens = [];
            let page = 0;
            const limit = 500;
            while (true) {
                const batch = await (0, get_tokens_js_1.getOwnedTokens)({
                    chains: insightEnabledChains.map((c) => (0, utils_js_1.getCachedChain)(c.chainId)),
                    client,
                    ownerAddress: wallet.getAccount()?.address || "",
                    queryOptions: {
                        limit,
                        metadata: "false",
                        page,
                    },
                });
                if (batch.length === 0) {
                    break;
                }
                // Convert to our format and filter out zero balances
                const tokensWithBalance = batch
                    .filter((b) => b.value > 0n)
                    .map((b) => ({
                    balance: b.value,
                    originToken: {
                        address: b.tokenAddress,
                        chainId: b.chainId,
                        decimals: b.decimals,
                        iconUri: "",
                        name: b.name,
                        prices: {
                            USD: 0,
                        },
                        symbol: b.symbol,
                    },
                }));
                allOwnedTokens = [...allOwnedTokens, ...tokensWithBalance];
                page += 1;
            }
            // 4. For each chain where we have owned tokens, fetch possible routes
            const chainsWithOwnedTokens = Array.from(new Set(allOwnedTokens.map((t) => t.originToken.chainId)));
            const allValidOriginTokens = new Map();
            // Add destination token if included
            if (includeDestinationToken) {
                const tokenKey = `${destinationToken.chainId}-${destinationToken.address.toLowerCase()}`;
                allValidOriginTokens.set(tokenKey, destinationToken);
            }
            // Fetch routes for each chain with owned tokens
            await Promise.all(chainsWithOwnedTokens.map(async (chainId) => {
                try {
                    // TODO (bridge): this is quite inefficient, need to fix the popularity sorting to really capture all users tokens
                    const routesForChain = await (0, Routes_js_1.routes)({
                        client,
                        destinationChainId: destinationToken.chainId,
                        destinationTokenAddress: destinationToken.address,
                        includePrices: true,
                        limit: 100,
                        maxSteps: 3,
                        originChainId: chainId,
                    });
                    // Add all origin tokens from this chain's routes
                    for (const route of routesForChain) {
                        // Skip if the origin token is the same as the destination token, will be added later only if includeDestinationToken is true
                        if (route.originToken.chainId === destinationToken.chainId &&
                            route.originToken.address.toLowerCase() ===
                                destinationToken.address.toLowerCase()) {
                            continue;
                        }
                        const tokenKey = `${route.originToken.chainId}-${route.originToken.address.toLowerCase()}`;
                        allValidOriginTokens.set(tokenKey, route.originToken);
                    }
                }
                catch (error) {
                    // Log error but don't fail the entire operation
                    console.warn(`Failed to fetch routes for chain ${chainId}:`, error);
                }
            }));
            // 5. Filter owned tokens to only include valid origin tokens
            const validOwnedTokens = [];
            for (const ownedToken of allOwnedTokens) {
                const tokenKey = `${ownedToken.originToken.chainId}-${ownedToken.originToken.address.toLowerCase()}`;
                const validOriginToken = allValidOriginTokens.get(tokenKey);
                if (validOriginToken) {
                    validOwnedTokens.push({
                        balance: ownedToken.balance,
                        originAmount: 0n,
                        originToken: validOriginToken, // Use the token with pricing info from routes
                    });
                }
            }
            // Sort by dollar balance descending
            validOwnedTokens.sort((a, b) => {
                const aDollarBalance = Number.parseFloat((0, units_js_1.toTokens)(a.balance, a.originToken.decimals)) *
                    (a.originToken.prices["USD"] || 0);
                const bDollarBalance = Number.parseFloat((0, units_js_1.toTokens)(b.balance, b.originToken.decimals)) *
                    (b.originToken.prices["USD"] || 0);
                return bDollarBalance - aDollarBalance;
            });
            const suitableOriginTokens = [];
            for (const token of validOwnedTokens) {
                if (includeDestinationToken &&
                    token.originToken.address.toLowerCase() ===
                        destinationToken.address.toLowerCase() &&
                    token.originToken.chainId === destinationToken.chainId) {
                    // Add same token to the front of the list
                    suitableOriginTokens.unshift(token);
                    continue;
                }
                suitableOriginTokens.push(token);
            }
            const transformedRoutes = [
                ...suitableOriginTokens.map((s) => ({
                    balance: s.balance,
                    originToken: s.originToken,
                    payerWallet: wallet,
                    type: "wallet",
                })),
            ];
            return transformedRoutes;
        },
        queryKey: [
            "bridge-routes",
            destinationToken.chainId,
            destinationToken.address,
            destinationAmount,
            payerWallet?.getAccount()?.address,
            includeDestinationToken,
        ], // 5 minutes
        refetchOnWindowFocus: false,
        staleTime: 5 * 60 * 1000,
    });
    return {
        data: routesQuery.data || [],
        error: routesQuery.error,
        isError: routesQuery.isError,
        isLoading: routesQuery.isLoading,
        isSuccess: routesQuery.isSuccess,
        refetch: routesQuery.refetch,
    };
}
//# sourceMappingURL=usePaymentMethods.js.map